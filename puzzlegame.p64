picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249NTM4NF1dbHo0ALcfAAAEhQAA-xB7WzBdPXtibXA9cHh1
AEMgEBAE-w8Cty4XnhceB74HBAAS8wYXnhcut-4CLGZsYWdzPTAscGFuX3gIAMx5PTAsem9vbT03
fSxnALA1Bz4HjgcOBx4HDggAQxcOB65VABGuDgAGHABPPgf_NV8AHlgjnyhfDwQAVx8oXyYfCAAZ
nwQAP-8PI2MAHv8AVxrOCh8aC74KHQvOG-5XQAAe_AASDzWfKw81Pw8PFp8yDy4IAFM-Mh8WPwwA
Uy8yPxYvDABfHzJfFh8MAAAIJAAIPAALWACPLp8xDzD-DxKrAEdCDxYaDokAcQ4fMg46Dh0LABUd
CgBRLQ4aDi0KADE9Hj0IABadBgAPoABSQQ8_DxAKAANFAQASACAHDhQAGB8UADYQDh0SAAA4ACId
DDQAUQw-Mhw7CQAWmwYAD7oAKZ8Xlw4-Dw84ng8HADBfN58eDzmHADiCLg83Hx4PNy4OAIMeDzc-
Hg83Hg4ALl8eCgAJIgAKPgAPqQBKTz4fHj51AAE-Lj8evQAOBBQAD6EASg9-AAZEHx4eHQwAFh0L
ACVdHjgATT0MHg9SAC8MnZ8AOwA0ARNODAAWP0ABB6kABbMAEC7LAAMMABBObgEvHg9AATMQIKEA
8QM3DzL-FwUPN38PDzL-HgYPOW8JAEEHDzlfCQDxAggPOU8PDzIfHh8O-x4FDzk-DQAxDw4fHgAR
BBEAGQ4RABFPEQAhHzIvAEFfDw8ORQARbwkAQQcPOX8JAOsGDzmPDwL-OgUPO-8PMrYAgy0xLjM5
NTgzAQAUNsUAUi4yOTE2AQASN9EAGjNyAaIgBP8PFw8yDxfPpgBQN68PDzJfAROPwwAAFAAXb8IA
ABAAAN8AEy8QABAvOAJgDw8OPx4fOAAB3QAfnwgAijACnzpDAR8SQwEmHzi1AgC-Cp8XDx8-DwmY
DzYGACVuDzSfGA8vmQBlMi4xODc1jwAzNjA0kABCNzAwNJIAHjmSAPACIwp-Fw8fXw8JDy9fGA80
DzYLAA8FAClAH18XCgoAMQ80f6cAHyOnAC0QIHwC9AI29wcLXh8r-xoHA04PK-8aCQcATz4K-QoF
AA7PnQ8p6w8bPgqdA-4EBQAW8ActCx8pPQP_BA8qLQ8pHgotA-4FDyodCwD7Dh0PG-4HDyodGgwN
Dxv_CQw9Cf4LDB0J-g0MCf5H7wBULTMuMzXjAAAbAgL5AEYtMC4wRQJPMDAzMkgEAgD7AM8yDyuX
C-8PBAqfGgMHAFXQC4cPKwqPDwr-GgYLfwcAMAcLbwcAMAgLXwcAgQQLHykfGgtPDABADykfDz8K
GD8OACEPGw8A8QMFGg8qDxoPG18PDyr-GgcPG28JAP8GBg8bjw8fKv8aAw8bvw-7Ag8b-w83OQE_
8ANHDysL-w8NDysfGgv-DwsPKz8IAFIJDysPGsAAMP8PBx0ABMEAYv8PBQ8rLw8AEC8PAIsECj8a
Gg8qLx0BDwcAH3E-Dw8r5w8qCgBPCv8aCgcAHUgJDxtPCAARB1EBX-sH-w82NgE_cDcPK-cCvw9e
AzEDG48IABEGuAERK8EBI18PQAEx-xoF2AADQAEw-xoEDwAXKg8AEU8PABAa8QEiBAMCAiIIAwEC
MQcDfwgAnQYDjw8PKpsPGzMBDwcASwF0AA4fBw8_ASsATwX-AjIGx88cDz4-Dw8jzxzPPg8QCgBK
fiTPEc8lDz-JAHQzMjAuMzEyZwVXLTE0OS61BgK-AB4x4wdQEgaXDxxjABOfxQAPCABMIySfyQAP
CABMIRGfJwEfEicBME8QBPDwRwB2EEB0Av8Bcg849yoPOj8PDzn-OioPOwkAQYsY-x4qAv8PcrMA
Ly0yMQMCYzcuMzc1MAEABLoAGjUBARBAbwIyDziXuQAAbAkPCAD-uU4Ynx4CbwMoLTcuAgQtAkcx
MC4xLgICLQIfNucCe2cxMS40MzeaAw6ZAx803wL-7zYyLji_BUs1LjA0EA4fNEkGNA9HAM8BiQrf
Mgf2Cg8gPw8G-yEKBQcAKGDPIR8_ryEKAHO-IQ8_Bx6fDAAyLg8QCwBkzyEODxABFwAADAACLwBh
ryEeDxC-CwBwnyEOBx4BrQsAQp0uDxAKABCtKwAQvQoAT-0KBTwFABB9DyD1Cg8V-HYKGTBFBwUZ
BS4tMCgBHzUoAQBQDzX3CgiLC0-6Cg8ZCAApM4pxigkARDEfPhEMADARDyc3ARcBEAAAAwEEDwBF
MQ4PECwAAD4BFCENACcRHg0ARgEOBx4NABguJwBbDg8QMYqCAC-6CggAIV8K_QoE-V8BNxAwXwFw
Ugf-FwoPNzUMbzj-HQoPPQoABqafHQ86rxIPOi8dEQCvPRgfGRofKysPOBYAADobDyQYAGg6fxcP
Nx8VAH--HQMPPR8_EgAQFh4SACMO74YABhUAEhQJAC8fLxEADR8YEAAMIR8ZCAAzOu8XFAEEFQAB
hgAFEgAfGhEADqkfKw8OfxIPOp8dFQBwCx8kHz4fHpgACRoAPw8rGxoAA0U6rxcHEAAOlwEHCgCb
Dv8SCg86-w9SIQJGMC4xNAkCJDMzIAJjMS4xMjQ5AQAvNjeZCAGEIDAE-w9CB58NAQWZAA8JAD4A
6gAYH10CCZ0BDxAABC8fGREABGM-DwfvFweYAQIRAAOgAQwQAC8fKxEACACVAABsAhkbEwD7AD0v
KxofGRgfLx8eHz4PJB0AJwsfHgA6HyQLHgAUG5gABREAA3cABBAALx8kEQAOFj6ZAAsUAAcJAR8e
EQAOHy8RAAwiOh_qAA6xAQ8JADAwDp8SqwIeQn0W1jQwMTc4NTcxNDI4NTerAs8yNDQwNDc2MTkw
NDRUBwIBzQQYYs0EFSsiAw8KAEYinyuIAQQNAAJIBA8JAAUQBP0BAwsADlAADwoAQAQSBB1iEgQI
sQgnOS4fBA-LCQEBBgQXMgYEBMMADwkAbgGnBSM-D-MADwkAQQFsBg58AA8JAGoDPQMfMtYBHQ-M
CgAPGQIeD0MAPQJWFOAPFz8OHzbfDh82Pw4PGHcBcT8YHzYPDs8GACEvGBgaQg7-GAoJAFO-GB8z
vxUAga8YDzMQDzavDwD-AB82jxgPMzAPF48YDzYPMxEAAcUOnxgPNhAPF58YDw5OACwXv2MAD4AA
AL8YPzYfM982HzNPNpIUAAn3AEswLjIw9wAKTRUCjhQC9wAK8wAE7QAfnwgAAjUfNn-aAAUKACUO
f8wAL58YCAADUz8YHzM-DAASLzIBBGkAEh8hAR8fDwADEi8uARYvSAAuFz9kAA_qADAdP2sBAGcB
HxJnASsQMLoE8CRS9xsGPvcaBgU_9xkGFT73GAYlPvcXBjU_9xYGRT5XDfUNDQYNRT5X9Q4GB1U_
V-UNBhcHADAMBicHADALBjcHAKAKBkdVPldV8QRXBwA-Af4DCACB-DhFBvcKVT5XNQb3C1U_VyUG
9wxVPlcVBvcNVT5XDQb3DlU_Vwb3DgZVPkcGDfUVPjcG9Rc_Jwb1GD4XBvUZPgcG9Ro_BvUb-kEK
GTR1AR8xVwwNIRAS3AJQI58rDyS8DEifJA8RCABfPyQfET8MAABeHyRfER8MAA8wAAYfnwgADE4P
EQ8kBAAkPw8KAA8aAAA-Iw8QBAABLx8P5QQdCkcLEBLlBPAAFg8j3ysPIx8PDyu-JB8RVgBCDyvf
JBIAANgAFV8WAAAOABN-GgAACgEVPxoAAA4AH180AA4NYACPJN8RDxD-DxTHACtPEBIEHyQBBgE_
AQVMAQtYAQ_MAQcvK58IAAwP-gEFDy4CLD4krxFeBA8QAQ4eNdcBERTXAbAkHw8PEB8RvyQPESMB
Et8IABIQoQETPxYAFn8MABAQCgACtQAAGgAWXwwADzQACgxgAF-vEf8PFsUALj-w-xFEACsBqBGg
RgwfPv8PCwxPPmsCYAgMDz4MTgoAUAYMDhcMzCegP-8PBQ4MBw8cXgsAUgQMHgxuFgAzAwyeCQAV
rggAASIAEo4PAEUEDxx_CgBAPj8QH0oAsAceLxAvP-8PBgcOEABQCg8cBw4jAHAGHB4MDxweCwAy
BQyOSAAQDmoAAQkAMRcMXgoAAogAIB8QfQAGiAAarggAIASeBgBQBQ8Qfg0JADEGHU4IAL8IHz8t
G-8PCyv6RvwILAA3AR83NwEwFL6uAAA5ABAEsAABIwEAsAASHLsAUB8-HQ4bDgDwHg7-DwcrDRsN
Bwz6DQ4MDxwM_g4MBwwO_g0MCRwOHB76Bw4MBwkMTg36BgwZBwgAkAUODCcMPg0L_kcBUQcJXgv6
gwBgDQv6AwyeBgAQrhwAkJ4L_gUNfg0L_iUBvwv6CBstG-oLK-o3eQwuIPD-AQAb9UgAGDGLFiYw
Lv8SD4sWAgEbDkByCZ8usCN-FA8uny8PMQkAFkMPLwl_CwA0DhluCgAkKV4KACM5TgoAEZ4IALAO
rzH-D7QJ-y4KDosBUi7_Cg8xCQA0BTkOCwAlBikLACUHGQsAJQgJCwAfCgkAFk8O-zEL4Q00AyEB
FAT9AA8JABQlfy_4ABVuzQAVXuIAFU73ABKesQAAIQFXlAmfLg4VAAVIARUEXAEVBHABAAoAAoQB
BzAADwgAiwHlAB8ylQErAtEQAEoCA5YBJP8v-AEPCgAVVQ8vCf4ITQEk-gcLADQp-gYLAD85-gVR
AgEStKEBBdcCBcgBFRTcARUU8AFCFA8ufgQCBzAADwgACwEhAR9ydgYeD7YCDg8JAHQPRgOzD8YC
AkYtMC444Sg8MS4zfAUfNSMQKQ9DAP--G88IEAQfDy8nPw8PJy8EAAg-Pw8fJAAQXi8n-w8c-iM3
Njg3bhAvNzVuEAoBkQBKKz4LLgIAig8mHycPJi4LAgA-Piv_cAAyBAEBggsuDycuCy4NBABEPh0P
JgwABRQALy3_4gA0CGoAAQQARw8mGwwPAAEEAC8_K28ARS4_G90AD08BOSkLLgIAAW8ALw8nTQFF
CrkBIi4NTQEGDwAO3wAPbwBAGgsCAA_8AT0PmQJVLAsuewMQG2QADtwAD24ARwHxABYMBAAvPizo
AzlCCw8PC7MEYCsOLw8LLQIAYw49Gz0OLQwAvysOLQ4LDQsOPS79dwAyYA8qDysPKvosEi8EABsr
BAAEGABXJh8qDyYQABsrBAABGAATP1AAD2wFNPIFLzA-Dw8wHw8KDzAvDw8wDw8KDzELADAaDw8J
ADAaDzEJAP8PPw8aPg8wDg8xGi4PMA4aDS4NDzEKDg0uDQoeDT4tiAU-MR4PJgcAEQs5BJAOCw4N
Ph8mPg0JAJEuDAseDS4LDB78Ag99ADtCDw8fPh0CANEiIS8PySIBDwAQDzg5ICc-BwD-DD8PAB4P
EAAvDw4HHgAtLg8QAC0ADgwNAD0vJzICL8EIBC8PJxYOF0AGYAUCAG0OBVAOBVC_D2I0MDM0MDkC
AB4xsCIPEg0EbwgIBHbwKE0AN6AmBT8PMBUeUAUOAwAQBgMAb0AHHkAHHmMAN1BwDw8ADgIAERAG
ADIAngAIAC-_CGQAN3VvDwVuBm4HAgAfBlsANxAAXAAIAgAPWwA0MCAMBDME0PsIDj8PDhsO-QYO
Gw4fA9D9Cg4LDgsOHSsODTsNFADAKw4NCx0LHQ4bLQsd1wQCBwACBAAwLRstLQBBDSsdOxMATA4b
Di0oAGA9Cy0bDh0NAAIkAHQrDj0LHQ4LawAUDX0Afz0O_wgO-RPfACYcOToBRWIAAmACAB-gWAA3
8QI-DycGHhcwDgdQDgZQDyFgDWcDD2AAJw9hAzkNTQCyFh8hPw8wDyEFHw9lAyJgBQIAD2MANPAO
EBAETw9TfpNOsy7THpMLBxMOkwsnowsnC0MHCyMHAPADJwsDCycLUwsnCycLcwtHC1MOFwDvUx4z
CwcLYy6zTpN_U06MACYeN4kDKQZuAgAPSgE3HgWJAw9CATX-Aj8Ptx4nryEODyAPOM8hDyDvBAAS
3w4PIN8hHi8VryE_vxWNACYNFA79A7c-D68hJx8PzyENBQ8P7yEF7gIA-wDODyUFDw_uLxUfD78V
Pw98ADQAZAEBnAL_Aw88BVAPDwVQDg88FTAeHTU_PaQkBxUHHjYILQ0YAl-wIHV-PEYALgCcADAh
YA6ZAP8GUAYPDzAXDzwPDwUeBh88Hw8-PD8PYQArAUsD8wlfEH8PnxBPD78QLw-fEB8P3xAPD-8Q
UA8NAO8vD78QTw_fEH8PXxBPD9EALgUvA89eBgBeBgBOBRA_BSBWAC4FKgPPAAdeAAdeEAZOIAU_
HAEucT8PbyhvDx8EAP8CPw8PKK8PDygfDw8ozw8PKA8IACwTH1AAEz9gAH5vD28o-w8FtAAYN3gT
HDG0AA-ZAwDva24bbhs_C64LHgvOCw4EAAy-HguuCz4bbhtua-58ADNrqz7LHusOAgBPHss_q2IA
L2AICAQPOGayBKxWHyAPOEYvIE8PBAAPoAIKATUtDx8lCvMACAgEZg1WDQVGDRVPDyVOAgAPVQAs
9ROkEgQPD-OGzvOIvkNfJ0M9g11zXWM9cz0DPXNdQ70TPTM9BADyAb4jnSM9Y50znUM9c60znSMe
ACNNIx4AAQYAIT1TBgBxMz0zPXNdEwoAEZMGAD8TXRMoAAUoTSMoAC9tAygAACCTnSAABSQAH70i
ABFAIz0jvggAeFO9Ez2zPXMeAG89A20TjUMeAAYhE10eAG09kz1TPZMeACMjTVwADyAABB8zwAAA
ETMGAAAyAAIOAA8qACX1BCOdM30TnTOdU30jPaOdM50znSMcAPUEQ11zXTNdc12TPUM9w11zXXNd
QxwAbPOIzvOGzisCRzU0LjKoLwVIMyw3Mh02CiwL9RNUCgTzHv8nDY8PEz8nEw5DPiM_Mw4zDgMe
Ez4TDlMOAz4DBAAwjw8DGgAjDjMGAFIDXgMeIwgAASAAkCMeAw4DLgMejREAUTNeAw5zKwAGIQAB
LwBxLo0DDlMOMwQAFCMhAAIfAAQEAABEAPQFEz4jLhM_Iz5DLgMOQz4THjMuMx4hAG2N8x7_Df22
HWMzLjE5MTDcKxYyvx2-NzAyMzgwOTUyNDHdKwMgqA44A-ABS-8nKf8PA-8bTP8nKv8PAkMD9QUe
o15zXoMecx4TPkNeQx6zHhN_EwQA8RD-DwIvG54tHo2ePZ5tHn0eDU4tni0evR4dfh0ePV4dCACg
-w8CEz4zPhMecwYAAAQAQr4TTkMIAAFFAOBTPhMeE24jHvwCHR59HgQAAgYAUh2_HS5tCAABSQAw
HR49GEZQTj0u-AI8AIFzvhMe8wAecwIABE0AgBM_Ux6DTvwCNQBhfb4dHv0AUAAHRgDBXj0ejU78
AhMesx5zBAAUU0MAAkEABAQAwE4zLvwCHT49Ph0ubQYAQD49Pl2QAAAMAEEeLV4tBAABUgD0Cm4t
HvwCI54zbiOeM55zbhMeg54jLpM_ky5MAPIJ-AJNXn1OTV59Xr1OHR6tXk1OXX5dTh1_kgDs-ALz
TP4q-AP9S-4p-APWAnI2OS4wNDgy0wElMTTBBSA1M9ABAdYBLzU31wIBDwEYAS8tMXAQHKQKBA8o
Ow4fD1sdAgBfDjsO-QpXACzvEBAEDzjGDQ8PDyDPIQUHAESPIc8VDyX-DwGsAB4cNqcGBPEGCAQA
zx8gDyFBDyAPIVEOYWYZCQn6Pw-bRQU3CAgEAwefQQ8lFVENBWENWAAxoB8PK04vJz47TisCAD8_
S55VADERayUV8gArDgsPDxsOCw4bDSsOKw0KAI8LDisOCw1rjWcAMYBLLw9LLgsvJ3AQEksEAG8u
PQsuS45dADRgGw8nGy8PYQACygDPGw4LDUsOCy0_Cy1LwQAyABsU0BsOLw8OCw5NCw5dC00YEW8L
PStdC81fAC4A3wP-EFYH4BfQJ8AXARAXkAEHIBGQAQAn0BcBwBcBsDfAMQCVCx0NZQrh8EVHoBcB
FwGQByEHAZAKAG9HAaBB8EVaAC8FuwDwAtABBwBFgAEARQGQBSEFAZBFAwAvoEFiADxgSIABAAgB
AgBjkBgBGAGQDAAfSGoALv4BBQUEDw8rDgsuGy4LDitOC04AVDc5ODYxAQADVwA2Mi43WC0PWQAG
IgsvXwMiDgsCAB9eXQA5jw8Pax4LTjtOVAA5vzsPDwsuSw4LLgtOqwA7YxseCx4LDgQAPx4bHl4A
PCA_CwIAPy4rDlgAOTArTw_rAD8LPjtXAD5vLhs_Cw4rBgE6EB9kARIOZAFPOz4LDhcCPRA_VQAv
Ow4XAj4-PiseEwI-EzujHj8_Cy7IAkAuHhuzAA9cADYvKz5aADphDwcELw_POhEzjw8fUhEAohER
TxQAAmYRAhwAbz8PjygvD3oAO__LPssO_wRO_wQOyz6LLtYASRFfBACTHyhPDy8oTw8fEAAP3gBP
QWsOyy4GAA-gADkQIBACNy8oLwQAUZ8PDygv0AAGCAATTyATDBgAAPQAuR8PHyi-Dz8oHw9PHAAT
zzgAES9YEwRcAA_6ACgcN8oCES_qEwJiAAYMAA96ATbwBQgIBF8VHyg-FT8oLxVPKB8VXygPBAAg
Dw8SAI8PTygvDz8oP3AAOvADHyhfFT8oPxVPKC8VXygfFQ8PdAAAaAAABgAASgMvPyhwADYCaBbw
HSV-Dx8lXxAfJU8PDyUvEBcfHC8QDyUvDx8lDxAXPh8cHg8lHw8PJQ4HHg8_qB_WDg8lDw8fJQ4N
AgA2LA4NAgB2HgwPDR4NDgIAdwsPEQ8MDQoCAKMPEQ8TDyQKCQoNAgBoCQofEwoJAgBjCA8PCA8j
DQCxCgkGCQgfDwgWCQYCAGAmCCUIJhkIAH9FGFYYdVhFEwEoHzgTAQCgJH8PDyQfI28kT6E0-zcj
Fw5PJA4NLw8NDhcObQ4NHA4XDp0MDQ4HDt0OvQ8R7QsPDd0LCt0PEwvNDwwPEwwLvQkcC70JLAuN
DwwJTBtNCBl8KylMowA5L-DwTgA2vwgQBA8jbQBhAAFgAgABb2EPEG8lcG4AOW9tB2EFUAEDAAxv
YQVvJQ8TeAA3vwQQBD0x8BwxPyUwVAAoDe4PET-eBhMvEAQCHAQAJgQALgQANgQAPgQPHgQ5Jj8P
eAQTDxwEACYEAC4EADYEAD4ED3AANvEFRAUEOC8PKB4IXigeCC4ILkgeKC4CALEeSA4ILggOCE4I
TggAES4IAAIKAAAWAH9uCC44Hhg_HgACeQ4YHhheCC5AABEODABRLkgOOB4QAABAAAJqAAAOABVe
PgAAgAAsPgj7Bjc2LjecKgT1EmM0LjAzMDUBAC84OcABARBE_gZBKB44Lt8AMh4oPn8AGDjjAAgE
ABluDgAB5wABMAAUHhQAJhheDAAE6QAFSABbHggOCB5EAARWAAJ2AHE_CD4oPjgukgAP6QA6DjEE
D4cCKk8QBH8PMwQOD28AOw80BBgPeQA2EAQ5GwM1BA9VADbwBygoBI8PBvcMBo4GBw8k-yMKFwBu
BhcKAGMLBwBeBicKADNOBjcKADM_BkcKADMuBlcKADMeBmcKADMOBncKACMGhwkAIgefCABhF-0T
FwD3AwDxBkcLBwv3DwA3DysrDPcOADcLDAcMCwkAsPcSADcMGwz3DwBnIgASJxoAUA8AJwwrFQAQ
NzkAExBGAE8PNQcGAgAQEwovAPIHZwn3DwBXCQ8K9w8ARxn3EAA3GQj3EAsANUcIGRYAkAgJ9xEA
Nwn3EjUAjwb3FQYADvAXcAEoHjJwAdAF-yEMBY8PBQ8hBf4MRiUQHggAMF0FLgcAME0FPgcAMD0F
TgcAMC0FXgcAMB0FbgcAMA0FfgcAIAWOBgB-DpX_DAD_FwMAPG8F-hUFAA3yADgJACkEBAAQBwEp
8AwFBy4NHgcFPg0FBy4HHgcFLgUHDgcNLg0FBwXWCS4FDgIpD58LKQBsIR8wTgA5DXQEH1BeADkP
YwQDD2IAOR8AJQU5DV4ABbMADxAFNxw3Rga-DyPdBwDRBQABsAEFACZf0QUPEN_YADlABgYEP9MD
-wAOBQcVBwUHBR4FBwU_BY5gACgvMTA-BzofNk4A-4T-A-8PNQreGs4a7hruGs4a3gr_S14APPAM
DzM4Do8PDggdCg4IDn0IHRoIDgh9CA0aCA4NCAAwDggaCAD-BA4IGh0IfQ4IDgodCA6NDjgO-TWC
ATsPTgD-vRGk_EMQEe4JEGO3QzL-DxsOABJnDgDwHBlPI1F_UU4xbjFOUU4xDjFuPyWePT49jl1O
-w8ZLpE_kS4xbjEukS6hTj0YAJJunS78GR4xPjEEABJuCABBUR4xPh8AX149Pj0eIQAAf0EuMT49
-gIgAAZvMZ6dPl0_HwAhQrEeMb57ABC9GwAhoS4ZAD0eIR4bACaBThsAJDGeGwAgPZ5RAB_eGwAT
AAoAZ749Hj0_PY0ADyEADkCukT7BSAFyzn0ufS59HkIBYM5RfjEOMXoBsO49Tn1OXT5dTvwZmgH7
AP5nCw8R-BsKC-5jCwr8GwkC9gAyOC4wMzk0ODQxMjY5ODRrIDI4MjliT083NTg2VwI7D04A-9rz
HwHYEAgQeBAIEAggWCAIEBggOCAYECggGCAoEDggCBA4EEggWBBYIEgQOBAIIDgaAAImAAIyAAI_
AD-Y8AGXADsv0xACAAYFawAfMZ4BOw_7Cf_5HyhPADsfJjoBOw8tDP-D8AkBxg8hHw8PIAaeDyEP
FR8PDg8hBn4NDxXzOmIOHQZeDR8LAFItBj4NLwsAUj0GHg0-CwBDTQYNTwoAQQ8VBUwKAHA9DB8w
BTwLNAD-Egw7BSwLGg4dDFsFHAsaDg0MewUMCxoODJsFDBoMuwX6AWgBOw9OAP--------------
----OFBtPTZ9fQ==
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI3IDEzOjIzOjQxIixtb2RpZmllZD0iMjAyNC0x
MS0yNSAwOToyMjo0NSIscmV2aXNpb249NDA0XV1sejQAyAAAADkxAADzFHtbMF09e2JtcD1weHUA
QyAQEATw8CxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sMQDvBQUEACcAByAXIEcABzA6AAsp
MTI7AP8RCgoEEFcgdwAXEBcQRwAnAGcAdxBXADcARzAnAHcgVxCHABn-BQYHBFcwFxAHEAcAJzAH
EAdABwBHQAAODvgADzEA--------------------------------------------------------
--------QlBtPTh9fQ==
:: gfx/bp_library.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI3IDE1OjA4OjUxIixtb2RpZmllZD0iMjAyNC0x
MS0yNSAwOToyMjo0NSIscmV2aXNpb249MTE1XV1sejQAuAAAACsxAADzFHtbMF09e2JtcD1weHUA
QyAQEATw8CxmbGFncz0wLHBhbl94CADHeT0wLHpvb209OH0sMQCvBQUEYAcgJyAHYDYACykxMjcA
cAkHBDAXABcEAL9QByAXUDdABxBXgHkAGf8FBgcEVzAXEAcQBwAnMAcQB0AHAEdAAA4O6gAPMQD-
--------------------------------------------------------------9CUG09OH19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCIsc3RvcmVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Il1d
:: includes/
:: includes/enias_font.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTIxIDA5OjQwOjA5Iixtb2RpZmllZD0iMjAyNC0w
NC0yMSAwOTo0MDowOSIscmV2aXNpb249MF1dbHo0ALEDAABgBwAA8lhweHUAAygACAAABBcI8G1v
PyAuQA4PMw5ADQwNQA0ADUAtMA8wDzwOCw8wIAMPDw4KAxAPPjZAPzAPPgAPYw82DxwPPggJCDAP
GIAMBVAcIB8KQA8EDwoPBLBGAAYADxsPEmAPCg8fBADwaxAPHg8rDwsPHg8oDysPHgAPIw0FDAYN
DzEABg8JBg8pHxEPLgAvBEAPHAYiBgQADw4FLxAFDw4QDxIMDgwBIB8EDx8fBGAHAjAPHoAWABgM
BwYSAAsdDzsPNw0LAAZMCwALDQ8wBAYDDgALDQoFCg0LAC8bDiUADhMLDADxLAsNAw8fHQsADhoF
Dz4cAAsdCx0LAAsdCQoFDCATABMgEwACDwEADxAIBwIHCAEQCwALMAcIAQ8gAQgHUADgDAAMAAsP
Iw8pDzUPKQM7APEQDi0ADx8dBB0EAAtDCwAETQQADg0DDw8DDQ4ADhMEI3IA8Vg7HQsALQ4tAAtM
CwAOOg0LAC0ELQBTDgAPNx4PKy8jAA0PNw4POy0ADk0OAAQtBBMACx8jDysNCw8gAAQdBC0ACRML
GgQADlwAXQsATQsMAB8jLysODxYAHQsMCx0ALQssAA4KBQwP9QDwIkYLABIGBwwYAAtFCwAHDwoP
EaAOAAIHUAsNCgkdDy4AAwQ9Dx0ACw0jDQsACgk9Dy7EAPABAw0LAA8cDzYGBCYADy4dCSsB8BQD
DxsPNz0ADAAPDiwLAAoADzgaDQsAEx0EHQBWDxwADxYOH7wAgQRdAAtNCwALtwAwPQsK8AEgN0P3
AAFxATAWBBYhAuAAXQ8uAE0PEgwALyMvK7sAwQ8SDAEdAD0JCgsADgIC9hcOAAUXAhcFAC8BACgA
Bh8IDxAfCAYADwoPBWAfAxwgb38AD1UPKgQA9gwAD0EPYw9-H10PdwkACR9jD3cJD0EJAA8RD0QE
AKAABwwPfAkEBQ8Q4ABgJh9fD38JvQBAIg93HwoAUA8IAA8q_gAhD3fIAvACKgAfHAkPXQ8cHxQA
DwgPHAkwALEqDzoACQ9nD2MPZ2MAEQl2APIHfw9jCQAFD3gvCA8PDwcACQ9jD2sPY4QA9AkIDxQP
Kg9dDyoPFA8IMA9VMAkPcw9jD3MeADEcD391AIEiEA9-DyIPFDEAgSIPfwAJD3cfRADzAhAPCgcA
D1APIBAPEQ8qD0QABwByCQ9rD3cPa0kAMX8AAwIA9AJvVRAPfg9CD1IPSg9CD34QAQwAQAEQAQoK
AB8KCQD---9oUA9KCgEA
:: includes/error_explorer.lua
b64$LS0tQGRpYWdub3N0aWMgZGlzYWJsZTogY2FzdC1sb2NhbC10eXBlLCBwYXJhbS10eXBlLW1p
c21hdGNoLCB1bmRlZmluZWQtZ2xvYmFsLCBtaXNzaW5nLXBhcmFtZXRlcgotLVtbcG9kX2Zvcm1h
dD0icmF3IixjcmVhdGVkPSIyMDI0LTEyLTE3IDExOjQwOjMzIixtb2RpZmllZD0iMjAyNC0xMi0x
NyAxMTo0MjoxNCIscmV2aXNpb249MV1dCi0tICMgcGljb3Ryb24gZXJyb3IgZXhwbG9yZXIKLS0K
LS0gYnkga2lyYQotLQotLSB2ZXJzaW9uIDAuMC40Ci0tCi0tIGFuIGludGVyYWN0aXZlIGVycm9y
IHNjcmVlbiBmb3IgcGljb3Ryb24uCi0tIG9uIGVycm9yLCBzaG93cyB0aGUgc3RhY2ssIGxvY2Fs
IHZhcmlhYmxlcywKLS0gYW5kIHRoZSBzb3VyY2UgY29kZSB3aGVuIGF2YWlsYWJsZS4KLS0KLS0g
IyMgdXNhZ2UKLS0KLS0gYGluY2x1ZGVgIG9yIGByZXF1aXJlYCBgZXJyb3JfZXhwbG9yZXIubHVh
YAotLSBpbiB5b3VyIHByb2dyYW0gX2FmdGVyXyBkZWZpbmluZyB5b3VyIGBfaW5pdGAsCi0tIGBf
dXBkYXRlYCwgYW5kIGBfZHJhd2AgZnVuY3Rpb25zLgotLQotLSBwcmVzcyBgdXBgIGFuZCBgZG93
bmAgdG8gbW92ZSB1cCBhbmQgZG93biBvbgotLSB0aGUgc3RhY2ssIHByZXNzIGB4YCBvciBgc3Bh
Y2VgIHRvIHRvZ2dsZSBmb250Ci0tIHNpemUuIGNsaWNrIG9uIHRhYmxlcyBpbiB0aGUgdmFyaWFi
bGUgdmlldyB0bwotLSBleHBhbmQgdGhlbS4KLS0KLS0gIyMgaG93IGl0IHdvcmtzCi0tCi0tIGlu
IG9yZGVyIHRvIGNhdGNoIGVycm9ycyBhbmQgaW5zcGVjdCBydW50aW1lCi0tIHN0YXRlLCB0aGlz
IHNjcmlwdCByZXBsYWNlcyBgX2luaXRgLCBgX3VwZGF0ZWAKLS0gYW5kIGBfZHJhd2AgZnVuY3Rp
b25zIHdpdGggb25lcyB0aGF0IGNhbGwgdGhlCi0tIG9yaWdpbmFsIG9uZXMgaW5zaWRlIGEgY29y
b3V0aW5lLgotLQotLSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3IsIGl0IHVzZXMgbHVhJ3MgZGVidWcK
LS0gbGlicmFyeSB0byBpbnNwZWN0IHRoZSBjb3JvdXRpbmUuIGEgY29weQotLSBvZiB0aGUgZXJy
b3IgaXMgYWxzbyBwcmludGVkIHRvIHRoZSBjb25zb2xlCi0tIHdpdGggcHJpbnRoIGlmIHlvdSdy
ZSBydW5uaW5nIHBpY290cm9uIGZyb20KLS0gdGhlIGNvbW1hbmQgbGluZS4KLS0KLS0gdGhlIGZv
bGxvd2luZyBkZWJ1ZyBhcGlzIGFyZSB1c2VkOgotLQotLSAtIGBkZWJ1Zy5nZXRpbmZvYAotLSAt
IGBkZWJ1Zy5nZXRsb2NhbGAKLS0gLSBgZGVidWcuZ2V0dXB2YWx1ZWAKLS0gLSBgZGVidWcudHJh
Y2ViYWNrYAotLQotLSAjIyB2ZXJzaW9uIGhpc3RvcnkgCi0tCi0tIHZlcnNpb24gMC4wLjQKLS0K
LS0gLSBhbHNvIGNhdGNoIGVycm9ycyBpbiBgX2luaXRgCi0tCi0tIHZlcnNpb24gMC4wLjMKLS0K
LS0gLSBhdXRvbWF0aWNhbGx5IGNob29zZSB0aGUgcmlnaHQgc3RhY2sgZnJhbWUKLS0gICBiYXNl
ZCBvbiB0aGUgZXJyb3IgbWVzc2FnZQotLSAtIG1vcmUgdGhvcm91Z2hseSBwcm90ZWN0IGZyb20g
ZXJyb3JzIGluIGVycm9yCi0tICAgZXhwbG9yZXIgaXRzZWxmCi0tCi0tIHZlcnNpb24gMC4wLjIK
LS0KLS0gLSBkb24ndCByZWdlbmVyYXRlIHN0YWNrIGluZm8gZXZlcnkgZHJhdwotLSAtIHNjcm9s
bCBzdGFjayBhbmQgdmFyaWFibGVzIGxpc3Qgd2l0aCBtb3VzZXdoZWVsCi0tIC0gY2xpY2sgb24g
c3RhY2sgdG8gc3dpdGNoIHN0YWNrIGZyYW1lcwotLSAtIGNsaWNrIG9uIHRhYmxlcyBpbiB2YXJp
YWJsZXMgdmlldyB0byBleHBhbmQgdGhlbQotLSAtIGVzY2FwZSBzdHJpbmdzIHdoZW4gcHJpbnRp
bmcgdGhlbQotLQotLSB2ZXJzaW9uIDAuMC4xCi0tCi0tIC0gYWRqdXN0IGNvbG9ycwotLSAtIGNv
ZGUgY2xlYW51cAotLSAtIHVzZSBgYnRucGAgaW5zdGVhZCBvZiBga2V5cGAKLS0gLSBzbGlnaHRs
eSBtb3JlIHRob3JvdWdoIGByZXNldGAKLS0gLSBkb24ndCBzaG93IHRlbXBvcmFyaWVzCi0tCi0t
IHZlcnNpb24gMC4wLjAgKHByZXJlbGVhc2UpCi0tCi0tIC0gaW5pdGlhbCBkaXNjb3JkIGJldGEK
Ci0tICMjIGxpY2Vuc2UKLS0KLS0gQ29weXJpZ2h0IDIwMjQgS2lyYSBCb29tCi0tIAotLSBQZXJt
aXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBv
YnRhaW5pbmcgYSBjb3B5Ci0tIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1l
bnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8KLS0gZGVhbCBpbiB0aGUgU29m
dHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0
aGUKLS0gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJp
YnV0ZSwgc3VibGljZW5zZSwgYW5kL29yCi0tIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwg
YW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCi0tIGZ1cm5pc2hl
ZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci0tCi0tIFRo
ZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxs
IGJlIGluY2x1ZGVkIGluCi0tIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2Yg
dGhlIFNvZnR3YXJlLgotLSAKLS0gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCd
LCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi0tIE9SIElNUExJRUQsIElO
Q0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklM
SVRZLAotLSBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VN
RU5ULiBJTiBOTyBFVkVOVCBTSEFMTAotLSBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVS
UyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgotLSBMSUFCSUxJVFks
IFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJ
U0lORwotLSBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBP
UiBUSEUgVVNFIE9SIE9USEVSCi0tIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi0tLS0gdXRp
bCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpsb2NhbCBmdW5jdGlv
biBmaWxlbmFtZV9vZiAocGF0aCkKICByZXR1cm4gcGF0aDptYXRjaCAoJ1teL10qJCcpCmVuZAoK
bG9jYWwgZnVuY3Rpb24gc2FmZV90b3N0cmluZyAodmFsdWUpCiAgaWYgdHlwZSAodmFsdWUpID09
ICdzdHJpbmcnIHRoZW4KICAgIHJldHVybiBzdHJpbmcuZm9ybWF0ICgnJXEnLCB2YWx1ZSkKICBl
bHNlCiAgICBsb2NhbCBzdWNjZXNzLCB2YWx1ZV9zdHJpbmcgPSBwY2FsbCAodG9zdHJpbmcsIHZh
bHVlKQogICAgcmV0dXJuIHN1Y2Nlc3MgYW5kIHZhbHVlX3N0cmluZwogICAgICAgICAgICAgICAg
ICAgb3IgKCdlcnJvciBkdXJpbmcgdG9zdHJpbmc6ICcgLi4gdG9zdHJpbmcgKHZhbHVlX3N0cmlu
ZykpCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gZ2V0X2xpbmVzICh0ZXh0KQogIGxvY2FsIGxp
bmVzID0ge30KICBmb3IgbGluZSBpbiB0ZXh0OmdtYXRjaCAoIiguLSlccj9cbiIpIGRvCiAgICB0
YWJsZS5pbnNlcnQgKGxpbmVzLCBsaW5lKQogIGVuZAogIGxvY2FsIGxhc3RfbGluZSA9IHRleHQ6
bWF0Y2ggKCcoW15cbl0qKSQnKQogIGlmIGxhc3RfbGluZSBhbmQgbGFzdF9saW5lIH49ICcnIHRo
ZW4KICAgIHRhYmxlLmluc2VydCAobGluZXMsIGxhc3RfbGluZSkKICBlbmQKICByZXR1cm4gbGlu
ZXMKZW5kCgpsb2NhbCBmdW5jdGlvbiBjb21wYXJlX2tleXMgKGEsIGIpCiAgbG9jYWwgdGEgPSB0
eXBlIChhLmtleSkKICBsb2NhbCB0YiA9IHR5cGUgKGIua2V5KQogIGlmIHRhIH49IHRiIHRoZW4K
ICAgIHJldHVybiB0YSA8IHRiCiAgZW5kCiAgaWYgdGEgPT0gJ251bWJlcicgb3IgdGEgPT0gJ3N0
cmluZycgdGhlbgogICAgcmV0dXJuIGEua2V5IDwgYi5rZXkKICBlbHNlCiAgICByZXR1cm4gc2Fm
ZV90b3N0cmluZyAoYS5rZXkpIDwgc2FmZV90b3N0cmluZyAoYi5rZXkpCiAgZW5kCmVuZAoKbG9j
YWwgZnVuY3Rpb24gc29ydCAodCwgZikKICAtLSBpbnNlcnRpb24gc29ydAogIGYgPSBmIG9yIGZ1
bmN0aW9uIChhLCBiKSByZXR1cm4gYSA8IGIgZW5kCiAgZm9yIGkgPSAxLCAjdC0xIGRvCiAgICBs
b2NhbCB2YWwgPSB0W2krMV0KICAgIGxvY2FsIGogPSBpCiAgICB3aGlsZSBqID49IDEgYW5kIG5v
dCBmKHRbal0sIHZhbCkgZG8KICAgICAgdFtqKzFdID0gdFtqXQogICAgICBqID0gaiAtIDEKICAg
IGVuZAogICAgdFtqKzFdID0gdmFsCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gYXBwcm9hY2gg
KGZyb20sIHRvKQogIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiAwLjI1CmVuZAoKbG9jYWwg
ZnVuY3Rpb24gcm91bmQgKHZhbHVlKQogIHJldHVybiBtYXRoLmZsb29yICh2YWx1ZSArIDAuNSkK
ZW5kCgpsb2NhbCBmdW5jdGlvbiBwYXJzZV9tZXNzYWdlX2Zvcl9sb2NhdGlvbiAobXNnKQogIGxv
Y2FsIHBhdGgsIGxpbmUsIGVyciA9IG1zZzptYXRjaCAoJ14oW146XSspOiglZCspOiguKikkJykK
ICByZXR1cm4gcGF0aCwgdG9udW1iZXIgKGxpbmUpLCBlcnIKZW5kCgotLS0tIHN0YXRlIC0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgX0cgPSBfRwpsb2NhbCBl
cnJvcl9tZXNzYWdlCmxvY2FsIGVycm9yX3RocmVhZApsb2NhbCBlcnJvcl90cmFjZWJhY2sKbG9j
YWwgaW5pdF9kb25lID0gZmFsc2UKbG9jYWwgdXNlX3NtYWxsX2ZvbnQgPSBmYWxzZQpsb2NhbCBt
b3VzZV93YXNfY2xpY2tlZCA9IGZhbHNlCgotLSBzdGFjayB2aWV3CmxvY2FsIHN0YWNrX2ZyYW1l
cyA9IHt9CmxvY2FsIGN1cnJlbnRfc3RhY2tfaW5kZXggPSAxCmxvY2FsIGhvdmVyZWRfc3RhY2tf
aW5kZXggPSBmYWxzZQpsb2NhbCBtb3VzZV9vdmVyX3N0YWNrID0gZmFsc2UKbG9jYWwgc3RhY2tf
bWF4X3Njcm9sbCA9IDAKbG9jYWwgc3RhY2tfc2Nyb2xsID0gMApsb2NhbCBzdGFja19zY3JvbGxf
c21vb3RoID0gMAoKLS0gdmFyaWFibGVzIHZpZXcKbG9jYWwgdmFyaWFibGVzID0ge30KbG9jYWwg
aG92ZXJlZF92YXJpYWJsZSA9IGZhbHNlCmxvY2FsIHZhcmlhYmxlc19tYXhfc2Nyb2xsID0gMAps
b2NhbCB2YXJpYWJsZXNfc2Nyb2xsID0gMApsb2NhbCB2YXJpYWJsZXNfc2Nyb2xsX3Ntb290aCA9
IDAKbG9jYWwgbW91c2Vfb3Zlcl92YXJpYWJsZXMgPSBmYWxzZQoKLS0gc291cmNlIHZpZXcKbG9j
YWwgc291cmNlX2xpbmVzID0ge30KCgotLS0tIG1haW4gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgVyA9IDQ4MApsb2NhbCBIID0gMjcwCgpsb2NhbCBmdW5j
dGlvbiByZWJ1aWxkICgpCiAgLS0gcmVidWlsZCBzdGFjayBmcmFtZSBpbmZvCiAgc3RhY2tfZnJh
bWVzID0ge30KICB2YXJpYWJsZXMgPSB7fQogIHNvdXJjZV9saW5lcyA9IHt9CiAgdmFyaWFibGVz
X3Njcm9sbCA9IDAKICB2YXJpYWJsZXNfc2Nyb2xsX3Ntb290aCA9IDAKCiAgZm9yIGkgPSAwLCAy
MCBkbwogICAgbG9jYWwgaW5mbyA9IGRlYnVnLmdldGluZm8gKGVycm9yX3RocmVhZCwgaSkKICAg
IGlmIG5vdCBpbmZvIHRoZW4KICAgICAgYnJlYWsKICAgIGVuZAoKICAgIGlmIGluZm8uc2hvcnRf
c3JjIHRoZW4KICAgICAgdGFibGUuaW5zZXJ0IChzdGFja19mcmFtZXMsIHsKICAgICAgICBmaWxl
bmFtZSA9IGZpbGVuYW1lX29mIChpbmZvLnNob3J0X3NyYyksCiAgICAgICAgcGF0aCA9IGluZm8u
c2hvcnRfc3JjLAogICAgICAgIGxpbmUgPSBpbmZvLmN1cnJlbnRsaW5lLAogICAgICAgIGRlcHRo
ID0gaSwKICAgICAgICBmbl9uYW1lID0gKGluZm8ubmFtZSBvciAoZmlsZW5hbWVfb2YgKGluZm8u
c2hvcnRfc3JjKSAuLiAnOicgLi4gdG9zdHJpbmcgKGluZm8ubGluZWRlZmluZWQpKSksCiAgICAg
ICAgc291cmNlID0gaW5mby5zb3VyY2UsCiAgICAgIH0pCiAgICBlbmQKICBlbmQKCiAgbG9jYWwg
ZnJhbWUgPSBzdGFja19mcmFtZXMgW2N1cnJlbnRfc3RhY2tfaW5kZXhdCgogIGlmIG5vdCBmcmFt
ZSB0aGVuCiAgICByZXR1cm4KICBlbmQKCiAgLS0gcmVidWlsZCB2YXJpYWJsZXMKICBkbwogICAg
bG9jYWwgbG9jYWxfaW5kZXggPSAxCiAgICByZXBlYXQKICAgICAgbG9jYWwgbmFtZSwgdmFsdWUg
PSBkZWJ1Zy5nZXRsb2NhbCAoZXJyb3JfdGhyZWFkLCBmcmFtZS5kZXB0aCwgbG9jYWxfaW5kZXgp
CiAgICAgIGlmIG5hbWUgdGhlbgogICAgICAgIGlmIG5hbWUgfj0gJyh0ZW1wb3JhcnkpJyB0aGVu
CiAgICAgICAgICB0YWJsZS5pbnNlcnQgKHZhcmlhYmxlcywgewogICAgICAgICAgICBrZXkgPSBu
YW1lLAogICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLAogICAgICAgICAgfSkKICAgICAgICBlbmQK
ICAgICAgICBsb2NhbF9pbmRleCA9IGxvY2FsX2luZGV4ICsgMQogICAgICBlbmQKICAgIHVudGls
IG5vdCBuYW1lCgogICAgbG9jYWwgaW5mbyA9IGRlYnVnLmdldGluZm8gKGVycm9yX3RocmVhZCwg
ZnJhbWUuZGVwdGgpCiAgICBpZiBpbmZvIGFuZCBpbmZvLmZ1bmMgdGhlbgogICAgICBsb2NhbCB1
cHZhbHVlX2luZGV4ID0gMQogICAgICByZXBlYXQKICAgICAgICBsb2NhbCBuYW1lLCB2YWx1ZSA9
IGRlYnVnLmdldHVwdmFsdWUgKGluZm8uZnVuYywgdXB2YWx1ZV9pbmRleCkKICAgICAgICBpZiBu
YW1lIHRoZW4KICAgICAgICAgIHRhYmxlLmluc2VydCAodmFyaWFibGVzLCB7CiAgICAgICAgICAg
IGtleSA9IG5hbWUsCiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUsCiAgICAgICAgICB9KQogICAg
ICAgICAgdXB2YWx1ZV9pbmRleCA9IHVwdmFsdWVfaW5kZXggKyAxCiAgICAgICAgZW5kCiAgICAg
IHVudGlsIG5vdCBuYW1lCiAgICBlbmQKICBlbmQKCiAgLS0gcmVidWlsZCBzb3VyY2UgbGluZXMK
ICBsb2NhbCBzb3VyY2UgPSBmcmFtZS5zb3VyY2UKICBpZiBzb3VyY2UgdGhlbgogICAgaWYgc3Ry
aW5nLnN1YiAoc291cmNlLCAxLCAxKSA9PSAnQCcgdGhlbgogICAgICBsb2NhbCBmaWxlbmFtZSA9
IHN0cmluZy5zdWIgKHNvdXJjZSwgMiwgI3NvdXJjZSkKICAgICAgc291cmNlID0gZmV0Y2ggKGZp
bGVuYW1lKQogICAgZW5kCiAgICBpZiBzb3VyY2UgYW5kIHR5cGUgKHNvdXJjZSkgPT0gJ3N0cmlu
ZycgdGhlbgogICAgICBzb3VyY2VfbGluZXMgPSBnZXRfbGluZXMgKHNvdXJjZSkKICAgIGVuZAog
IGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGVycm9yX3VwZGF0ZSAoKQogIGxvY2FsIGxhc3RfaW5k
ZXggPSBjdXJyZW50X3N0YWNrX2luZGV4CiAgaWYgYnRucCAoNSkgb3Iga2V5cCAnc3BhY2UnIHRo
ZW4KICAgIHVzZV9zbWFsbF9mb250ID0gbm90IHVzZV9zbWFsbF9mb250CiAgZW5kCiAgaWYgYnRu
cCAoMikgdGhlbgogICAgY3VycmVudF9zdGFja19pbmRleCA9IG1hdGgubWF4ICgxLCBjdXJyZW50
X3N0YWNrX2luZGV4IC0gMSkKICAgIHN0YWNrX3Njcm9sbCA9IG1hdGgubWluIChjdXJyZW50X3N0
YWNrX2luZGV4LTEsIHN0YWNrX3Njcm9sbCkKICBlbmQKICBpZiBidG5wICgzKSB0aGVuCiAgICBj
dXJyZW50X3N0YWNrX2luZGV4ID0gbWF0aC5taW4gKCNzdGFja19mcmFtZXMsIGN1cnJlbnRfc3Rh
Y2tfaW5kZXggKyAxKQogICAgc3RhY2tfc2Nyb2xsID0gbWF0aC5tYXggKChjdXJyZW50X3N0YWNr
X2luZGV4KSAtICgjc3RhY2tfZnJhbWVzIC0gc3RhY2tfbWF4X3Njcm9sbCksIHN0YWNrX3Njcm9s
bCkKICBlbmQKCiAgbG9jYWwgXywgXywgY2xpY2ssIF8sIHdoZWVsID0gbW91c2UgKCkKICBpZiBt
b3VzZV9vdmVyX3N0YWNrIHRoZW4KICAgIHN0YWNrX3Njcm9sbCA9IG1hdGgubWF4ICgwLCBtYXRo
Lm1pbiAoc3RhY2tfc2Nyb2xsIC0gd2hlZWwgKiAyLCBzdGFja19tYXhfc2Nyb2xsKSkKICBlbmQK
ICBzdGFja19zY3JvbGxfc21vb3RoID0gYXBwcm9hY2ggKHN0YWNrX3Njcm9sbF9zbW9vdGgsIHN0
YWNrX3Njcm9sbCkKICBpZiBtb3VzZV9vdmVyX3ZhcmlhYmxlcyB0aGVuCiAgICB2YXJpYWJsZXNf
c2Nyb2xsID0gbWF0aC5tYXggKDAsIG1hdGgubWluICh2YXJpYWJsZXNfc2Nyb2xsIC0gd2hlZWwg
KiAyLCB2YXJpYWJsZXNfbWF4X3Njcm9sbCkpCiAgZW5kCiAgdmFyaWFibGVzX3Njcm9sbF9zbW9v
dGggPSBhcHByb2FjaCAodmFyaWFibGVzX3Njcm9sbF9zbW9vdGgsIHZhcmlhYmxlc19zY3JvbGwp
CgogIGNsaWNrID0gY2xpY2sgfj0gMAogIGlmIGNsaWNrIGFuZCBub3QgbW91c2Vfd2FzX2NsaWNr
ZWQgdGhlbgogICAgaWYgaG92ZXJlZF9zdGFja19pbmRleCB0aGVuCiAgICAgIGN1cnJlbnRfc3Rh
Y2tfaW5kZXggPSBob3ZlcmVkX3N0YWNrX2luZGV4CiAgICBlbmQKICAgIGlmIGhvdmVyZWRfdmFy
aWFibGUgYW5kIHR5cGUgKGhvdmVyZWRfdmFyaWFibGUudmFsdWUpID09ICd0YWJsZScgdGhlbgog
ICAgICBpZiBob3ZlcmVkX3ZhcmlhYmxlLmNvbnRlbnRzIHRoZW4KICAgICAgICBob3ZlcmVkX3Zh
cmlhYmxlLmNvbnRlbnRzID0gbmlsCiAgICAgIGVsc2UKICAgICAgICBsb2NhbCBjb250ZW50cyA9
IHt9CiAgICAgICAgaG92ZXJlZF92YXJpYWJsZS5jb250ZW50cyA9IGNvbnRlbnRzCiAgICAgICAg
Zm9yIGssdiBpbiBwYWlycyAoaG92ZXJlZF92YXJpYWJsZS52YWx1ZSkgZG8KICAgICAgICAgIHRh
YmxlLmluc2VydCAoY29udGVudHMsIHsKICAgICAgICAgICAga2V5ID0gaywKICAgICAgICAgICAg
dmFsdWUgPSB2LAogICAgICAgICAgfSkKICAgICAgICBlbmQKICAgICAgICBzb3J0IChjb250ZW50
cywgY29tcGFyZV9rZXlzKQogICAgICBlbmQKICAgIGVuZAogIGVuZAogIG1vdXNlX3dhc19jbGlj
a2VkID0gY2xpY2sKCiAgaWYgY3VycmVudF9zdGFja19pbmRleCB_PSBsYXN0X2luZGV4IHRoZW4K
ICAgIHJlYnVpbGQoKQogIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGVycm9yX2RyYXcgKCkKICBs
b2NhbCBwcmVmaXggPSB1c2Vfc21hbGxfZm9udCBhbmQgJ1wwMTQnIG9yICcnCiAgbG9jYWwgZm9u
dF9oZWlnaHQgPSAodXNlX3NtYWxsX2ZvbnQgYW5kIDYgb3IgMTEpCiAgbG9jYWwgbXgsIG15ID0g
bW91c2UoKQogIGxvY2FsIG92ZXJfc2VjdGlvbiA9IGZhbHNlCiAgbG9jYWwgeDAsIHkwLCB4LCB5
CgogIGxvY2FsIGZ1bmN0aW9uIGdvX3RvIChuZXdfeCwgbmV3X3kpCiAgICB4MCwgeTAgPSBuZXdf
eCwgbmV3X3kKICAgIHgsIHkgPSB4MCwgeTAKICBlbmQKCiAgbG9jYWwgZnVuY3Rpb24gc2VjdGlv
biAoc3gsIHN5LCBzdywgc2gpCiAgICBvdmVyX3NlY3Rpb24gPQogICAgICBteCA_PSBzeCBhbmQg
bXggPCBzeCArIHN3IGFuZAogICAgICBteSA_PSBzeSBhbmQgbXkgPCBzeSArIHNoCiAgICBjbGlw
IChzeCwgc3ksIHN3LCBzaCkKICAgIGdvX3RvKHN4KzIsIHN5KzIpCiAgZW5kCgogIGxvY2FsIGZ1
bmN0aW9uIHByaW50X2hvcml6b250YWwgKHRleHQsIGNvbG9yKQogICAgbG9jYWwgbmV3X3gsIF9u
ZXdfeSA9IHByaW50IChwcmVmaXggLi4gdGV4dCwgeCwgeSwgY29sb3IpCiAgICB4ID0gbmV3X3gK
ICBlbmQKCiAgbG9jYWwgZnVuY3Rpb24gcHJpbnRfbGluZSAodGV4dCwgY29sb3IpCiAgICBsb2Nh
bCBfbmV3X3gsIG5ld195ID0gcHJpbnQgKHByZWZpeCAuLiB0ZXh0LCB4LCB5LCBjb2xvcikKICAg
IHggPSB4MAogICAgeSA9IG5ld195CiAgZW5kCgogIC0tIGRyYXcgc2V0dXAKICBjbHMgKDApCiAg
LS0gbGlnaHRlciBkYXJrIGdyYXkgZm9yIHJlYWRhYmlsaXR5CiAgcGFsICg1LCAweGZmNzA3MDcw
LCAyKQogIGNvbG9yICg1KQoKICAtLSBlcnJvciBtZXNzYWdlCiAgc2VjdGlvbiAoMCwgMCwgVywg
SC8yKQogIG1vdXNlX292ZXJfc3RhY2sgPSBvdmVyX3NlY3Rpb24KCiAgbG9jYWwgbG9jX3BhdGgs
IGxvY19saW5lLCBlcnIgPSBwYXJzZV9tZXNzYWdlX2Zvcl9sb2NhdGlvbiAoZXJyb3JfbWVzc2Fn
ZSkKICBpZiBsb2NfcGF0aCB0aGVuCiAgICBwcmludF9saW5lICgnZXJyb3IgYXQgJyAuLiBsb2Nf
cGF0aCAuLiAnOicgLi4gbG9jX2xpbmUgLi4gJzonLCA2KQogICAgcHJpbnRfbGluZSAoJyAgJyAu
LiBlcnIsIDgpCiAgZWxzZQogICAgcHJpbnRfbGluZSAoJ2Vycm9yOicsIDYpCiAgICBwcmludF9s
aW5lICgnICAnIC4uIGVycm9yX21lc3NhZ2UsIDgpCiAgZW5kCgogIC0tIHN0YWNrIGZyYW1lcwog
IHByaW50X2xpbmUgKCdzdGFjazonLCA2KQogIHNlY3Rpb24gKDAsIHksIFcsIEgvMi15KQogIGxv
Y2FsIHN0YWNrX3RvcF95ID0geQogIHkgPSB5IC0gcm91bmQgKHN0YWNrX3Njcm9sbF9zbW9vdGgg
KiBmb250X2hlaWdodCkKICBsb2NhbCBsYXN0X2hvdmVyZWRfc3RhY2tfaW5kZXggPSBob3ZlcmVk
X3N0YWNrX2luZGV4CiAgaG92ZXJlZF9zdGFja19pbmRleCA9IGZhbHNlCiAgZm9yIGksIGZyYW1l
IGluIGlwYWlycyAoc3RhY2tfZnJhbWVzKSBkbwogICAgY29sb3IgKGxhc3RfaG92ZXJlZF9zdGFj
a19pbmRleCA9PSBpIGFuZCA3IG9yCiAgICAgICAgICAgY3VycmVudF9zdGFja19pbmRleCA9PSBp
IGFuZCA2IG9yIDUpCgogICBsb2NhbCB5X2JlZm9yZSA9IHkKICAgIHByaW50X2xpbmUgKHN0cmlu
Zy5mb3JtYXQgKCcgICVzOiVkIGluIGZ1bmN0aW9uICVzJywKICAgICAgZnJhbWUuZmlsZW5hbWUs
IGZyYW1lLmxpbmUsIGZyYW1lLmZuX25hbWUgKSkKICAgIGlmIG92ZXJfc2VjdGlvbiB0aGVuCiAg
ICAgIGlmIG15ID49IHlfYmVmb3JlIGFuZCBteSA8IHkgdGhlbgogICAgICAgIGhvdmVyZWRfc3Rh
Y2tfaW5kZXggPSBpCiAgICAgIGVuZAogICAgZW5kCiAgZW5kCiAgc3RhY2tfbWF4X3Njcm9sbCA9
ICNzdGFja19mcmFtZXMgLSAoSC8yIC0gc3RhY2tfdG9wX3kpIC8gZm9udF9oZWlnaHQKCiAgbG9j
YWwgZnJhbWUgPSBzdGFja19mcmFtZXMgW2N1cnJlbnRfc3RhY2tfaW5kZXhdCiAgaWYgbm90IGZy
YW1lIHRoZW4KICAgIHJldHVybgogIGVuZAoKICAtLSB2YXJpYWJsZXMKICBzZWN0aW9uICgwLCBI
LzIsIFcvMiwgSC8yKQogIG1vdXNlX292ZXJfdmFyaWFibGVzID0gb3Zlcl9zZWN0aW9uCiAgcHJp
bnRfbGluZSAoJ3ZhcmlhYmxlczonLCA2KQogIHNlY3Rpb24gKDAsIHksIFcvMiwgSC15KQogIGxv
Y2FsIHZhcmlhYmxlc190b3BfeSA9IHkKICB5ID0geSAtIHJvdW5kICh2YXJpYWJsZXNfc2Nyb2xs
X3Ntb290aCAqIGZvbnRfaGVpZ2h0KQogIGxvY2FsIGxhc3RfaG92ZXJlZF92YXJpYWJsZSA9IGhv
dmVyZWRfdmFyaWFibGUKICBob3ZlcmVkX3ZhcmlhYmxlID0gZmFsc2UKICBsb2NhbCB2YXJpYWJs
ZV9jb3VudCA9IDAKICBsb2NhbCBmdW5jdGlvbiBkcmF3X3ZhcmlhYmxlICh2YXJpYWJsZSwgaW5k
ZW50KQogICAgdmFyaWFibGVfY291bnQgPSB2YXJpYWJsZV9jb3VudCArIDEKICAgIGxvY2FsIGhv
dmVyZWQgPSB2YXJpYWJsZSA9PSBsYXN0X2hvdmVyZWRfdmFyaWFibGUKICAgIGxvY2FsIHlfYmVm
b3JlID0geQogICAgcHJpbnRfaG9yaXpvbnRhbCAoaW5kZW50IC4uIHZhcmlhYmxlLmtleSwgaG92
ZXJlZCBhbmQgNyBvciA2KQogICAgcHJpbnRfaG9yaXpvbnRhbCAoJzogJywgdmFyaWFibGUgPT0g
bGFzdF9ob3ZlcmVkX3ZhcmlhYmxlIGFuZCA3IG9yIDUpCiAgICBwcmludF9saW5lIChzYWZlX3Rv
c3RyaW5nKHZhcmlhYmxlLnZhbHVlKSkKCiAgICBpZiBvdmVyX3NlY3Rpb24gYW5kIHR5cGUgKHZh
cmlhYmxlLnZhbHVlKSA9PSAndGFibGUnIHRoZW4KICAgICAgaWYgbXggPj0gMCBhbmQgbXggPCBX
LzIgYW5kIG15ID49IHlfYmVmb3JlIGFuZCBteSA8IHkgdGhlbgogICAgICAgIGhvdmVyZWRfdmFy
aWFibGUgPSB2YXJpYWJsZQogICAgICBlbmQKICAgIGVuZAoKICAgIGlmIHZhcmlhYmxlLmNvbnRl
bnRzIHRoZW4KICAgICAgZm9yIF8sIHYgaW4gaXBhaXJzICh2YXJpYWJsZS5jb250ZW50cykgZG8K
ICAgICAgICBkcmF3X3ZhcmlhYmxlICh2LCBpbmRlbnQgLi4gJyAgJykKICAgICAgZW5kCiAgICBl
bmQKICBlbmQKICBmb3IgXywgdmFyaWFibGUgaW4gaXBhaXJzICh2YXJpYWJsZXMpIGRvCiAgICBk
cmF3X3ZhcmlhYmxlICh2YXJpYWJsZSwgJyAgJykKICBlbmQKICB2YXJpYWJsZXNfbWF4X3Njcm9s
bCA9IHZhcmlhYmxlX2NvdW50IC0gKEggLSB2YXJpYWJsZXNfdG9wX3kpIC8gZm9udF9oZWlnaHQK
CiAgLS0gc291cmNlCiAgc2VjdGlvbiAoVy8yLCBILzIsIFcvMiwgSC8yKQogIHByaW50X2xpbmUg
KCdzb3VyY2Ugb2YgJyAuLiBmcmFtZS5wYXRoIC4uICc6JywgNikKICBsb2NhbCBjb250ZXh0ID0g
dXNlX3NtYWxsX2ZvbnQgYW5kIDEwIG9yIDUKICBsb2NhbCBpX21pbiA9IG1hdGgubWF4ICgxLCBm
cmFtZS5saW5lIC0gY29udGV4dCkKICBsb2NhbCBpX21heCA9IG1hdGgubWluICgjc291cmNlX2xp
bmVzLCBmcmFtZS5saW5lICsgY29udGV4dCkKICBmb3IgaSA9IGlfbWluLCBpX21heCBkbwogICAg
Y29sb3IgKGkgPT0gZnJhbWUubGluZSBhbmQgNiBvciA1KQogICAgcHJpbnRfaG9yaXpvbnRhbCAo
c3RyaW5nLmZvcm1hdCAoJyU0ZCAnLCBpKSkKICAgIHByaW50X2xpbmUgKHNvdXJjZV9saW5lcyBb
aV0pCiAgZW5kCgogIGNsaXAgKCkKZW5kCgotLS0tIHRha2luZyBvdmVyIGR1cmluZyBlcnJvcnMg
LS0tLS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgZnVuY3Rpb24gcmVzZXQgKCkKICAtLSBiYXNlZCBv
biByZXNldCgpIGZyb20gL3N5c3RlbS9saWIvaGVhZC5sdWEKICAtLSBzZWUgdGhhdCBmbiBmb3Ig
aW5mbwogIG5vdGUgKCkKICAtLSBwaWNvdHJvbiBzZWdmYXVsdHMgaWYgd2UgY2FsbCBjbGlwKCkg
ZHVyaW5nIGluaXQKICBpZiBpbml0X2RvbmUgdGhlbgogICAgY2xpcCAoKQogIGVuZAogIGNhbWVy
YSAoKQogIHBhbCAoKQogIHBhbHQgKCkKICBtZW1zZXQgKDB4NTUxZiwgMCwgOSkKICBwb2tlICgw
eDU1MDgsIDB4M2YpCiAgcG9rZSAoMHg1NTA5LCAweDNmKQogIHBva2UgKDB4NTUwYSwgMHgzZikK
ICBwb2tlICgweDU1MGIsIDB4MDApCiAgY29sb3IgKDYpCiAgZmlsbHAgKCkKICBwb2tlICgweDVm
NTYsIDB4NDApCiAgcG9rZSAoMHg1ZjU3LCAweDU2KQogIHBva2UgKDB4NDAwMCwgZ2V0IChmZXRj
aCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpCiAgcG9rZSAoMHg1NjAwLCBnZXQgKGZldGNoIi9z
eXN0ZW0vZm9udHMvcDguZm9udCIpKQogIHBva2UgKDB4NTYwNiwgcGVlayAoMHg1NjAwKSAqIDQp
CiAgcG9rZSAoMHg1NjA1LCAweDIpCiAgcG9rZSAoMHg1ZjI4LCA2NCkKICBwb2tlICgweDVmMjks
IDY0KQplbmQKCmxvY2FsIGZ1bmN0aW9uIG9uX2Vycm9yICh0aHJlYWQsIG1lc3NhZ2UpCiAgLS0g
ZG8gdGhpcyBmaXJzdCBpbiBjYXNlIHdlIGhpdCBhbm90aGVyIGVycm9yCiAgZXJyb3JfdHJhY2Vi
YWNrID0gZGVidWcudHJhY2ViYWNrICh0aHJlYWQsIG1lc3NhZ2UpCiAgcHJpbnRoIChlcnJvcl90
cmFjZWJhY2spCgogIGVycm9yX3RocmVhZCA9IHRocmVhZAogIGVycm9yX21lc3NhZ2UgPSB0b3N0
cmluZyAobWVzc2FnZSkKICByZXNldCAoKQogIHJlYnVpbGQgKCkKICAtLSBqdW1wIHRvIHRoZSBw
cm9wZXIgc3RhY2sgZnJhbWUgaWYgd2UgY2FuCiAgbG9jYWwgbG9jX3BhdGgsIGxvY19saW5lID0g
cGFyc2VfbWVzc2FnZV9mb3JfbG9jYXRpb24gKGVycm9yX21lc3NhZ2UpCiAgZm9yIGksIGZyYW1l
IGluIGlwYWlycyAoc3RhY2tfZnJhbWVzKSBkbwogICAgaWYgZnJhbWUucGF0aCA9PSBsb2NfcGF0
aCBhbmQgZnJhbWUubGluZSA9PSBsb2NfbGluZSB0aGVuCiAgICAgIGN1cnJlbnRfc3RhY2tfaW5k
ZXggPSBpCiAgICAgIHJlYnVpbGQgKCkKICAgICAgYnJlYWsKICAgIGVuZAogIGVuZAplbmQKCi0t
LS0gaW5zdGFsbCBtYWluIGV2ZW50cyB0aGF0IGNhdGNoIGVycm9ycyAtLS0tLS0tCgpsb2NhbCB1
c2VyX2luaXQgPSByYXdnZXQgKF9HLCAnX2luaXQnKQpsb2NhbCB1c2VyX3VwZGF0ZSA9IHJhd2dl
dCAoX0csICdfdXBkYXRlJykKbG9jYWwgdXNlcl9kcmF3ID0gcmF3Z2V0IChfRywgJ19kcmF3JykK
CmFzc2VydCAodXNlcl9kcmF3IGFuZCB1c2VyX3VwZGF0ZSwKICAncGxlYXNlIGluY2x1ZGUgaW5z
dGFsbF9lcnJvcl9oYW5kbGVyIGFmdGVyIGRlZmluaW5nIGJvdGggX3VwZGF0ZSBhbmQgX2RyYXcn
KQoKbG9jYWwgZnVuY3Rpb24gY2FsbF9lcnJvcl9ldmVudCAoZm4sIC4uLikKICAtLSBpZiB0aGVy
ZSdzIGFuIGVycm9yIGluIG91ciB1cGRhdGUgb3IgZHJhdywgdGhyb3cgdGhlCiAgLS0gb3JpZ2lu
YWwgZXJyb3IgYXMgd2VsbCBhcyB0aGUgbmV3IGVycm9yCiAgbG9jYWwgc3VjY2VzcywgZXJyID0g
cGNhbGwgKGZuLCAuLi4pCiAgaWYgbm90IHN1Y2Nlc3MgdGhlbgogICAgZXJyb3IgKGVycm9yX3Ry
YWNlYmFjayAuLiAnXG5cbmVycm9yIGR1cmluZyBlcnJvciBoYW5kbGluZzogJyAuLiB0b3N0cmlu
ZyAoZXJyKSkKICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBjYWxsX3Byb3RlY3RlZCAoZm4pCiAg
LS0gbmVlZCB0byB1c2UgY29yZXN1bWUgZXRjLiBhbmQgbm90IGNvcm91dGluZS5yZXN1bWUgZXRj
LgogIC0tIGZvciBwaWNvdHJvbiBjb21wYXRpYmlsaXR5CiAgbG9jYWwgdGhyZWFkID0gY29jcmVh
dGUgKGZuKQogIGxvY2FsIHN1Y2Nlc3MsIG1lc3NhZ2UgPSBjb3Jlc3VtZSh0aHJlYWQpCiAgaWYg
Y29zdGF0dXMgKHRocmVhZCkgfj0gJ2RlYWQnIHRoZW4KICAgIGNhbGxfZXJyb3JfZXZlbnQgKG9u
X2Vycm9yLCB0aHJlYWQsICdzZXR1cF9lcnJvcl9kaXNwbGF5Lmx1YTogX3VwZGF0ZSBhbmQgX2Ry
YXcgc2hvdWxkblwndCB5aWVsZCcpCiAgZW5kCiAgaWYgbm90IHN1Y2Nlc3MgdGhlbgogICAgY2Fs
bF9lcnJvcl9ldmVudCAob25fZXJyb3IsIHRocmVhZCwgbWVzc2FnZSkKICBlbmQKZW5kCgppZiB1
c2VyX2luaXQgdGhlbgogIGZ1bmN0aW9uIF9pbml0ICgpCiAgICBjYWxsX3Byb3RlY3RlZCAodXNl
cl9pbml0KQogICAgaW5pdF9kb25lID0gdHJ1ZQogIGVuZAplbHNlCiAgaW5pdF9kb25lID0gdHJ1
ZQplbmQKCmZ1bmN0aW9uIF91cGRhdGUgKCkKICBpZiBlcnJvcl90aHJlYWQgdGhlbgogICAgY2Fs
bF9lcnJvcl9ldmVudCAoZXJyb3JfdXBkYXRlKQogIGVsc2UKICAgIGNhbGxfcHJvdGVjdGVkICh1
c2VyX3VwZGF0ZSkKICBlbmQKZW5kCgpmdW5jdGlvbiBfZHJhdyAoKQogIGlmIGVycm9yX3RocmVh
ZCB0aGVuCiAgICBjYWxsX2Vycm9yX2V2ZW50IChlcnJvcl9kcmF3KQogIGVsc2UKICAgIGNhbGxf
cHJvdGVjdGVkICh1c2VyX2RyYXcpCiAgZW5kCmVuZA==
:: includes/pancelor_mouse.lua
--[[ usage:
include "pancelor-mouse.lua"

function _update()
    mbtn_update()

    if mbtnp(0) then notify("LMB pressed "..time()) end
    if mbtnr(1) then notify("RMB released "..time()) end
    if mbtn(2) then notify("MMB held "..time()) end

    -- advanced: examine full bitfield:
    if mbtnp()&3==3 then notify("LMB+RMB simul-press :O "..time()) end
end
]]

-- mouse state bitfields
local _mbtn,_mbtnp,_mbtnr = 0,0,0

local function mbtn_helper(bits, n)
    -- "not" required b/c "or" branch can be false
    return not n
        and bits
        or bits&(1<<n)~=0
end

-- n: mouse button index; 0=LMB, 1=RMB, 2=MMB.
-- if called with no params, returns bitfield
function mbtn( n) return mbtn_helper(_mbtn,n) end
function mbtnp( n) return mbtn_helper(_mbtnp,n) end
function mbtnr( n) return mbtn_helper(_mbtnr,n) end

-- call this at the start of _update()
function mbtn_update()
    local _,_,now = mouse()
    _mbtnp,_mbtnr = now&~_mbtn,~now&_mbtn
    _mbtn = now
end
:: includes/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI3IDEyOjQwOjIwIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCJdXQ==
:: map/
:: map/blueprints/
:: map/blueprints/butterfly.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTExIDA5OjQyOjAzIixtb2RpZmllZD0iMjAyNS0w
Mi0xMiAxMzo1Mjo0NCIscmV2aXNpb249MTMyXV1sejQA5wAAAG0EAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDE1LDgsIjABAC4uZDAQAAwEAAgBAC9kMAEACx9kKAAcDgEADzAADxtkEAAOAQAOLAAP
AQAxH2QUAAEPHAAKDwEALfEIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2
CgAQdwoAj3pvb209MX0sNgIJL2MwBAAvCAEAH2MEAAAIAQAXYwQADwEAAQQYAA8gAAkEBAAPAQAZ
HmMEAA8BABIbYwQADwEAIRdjBAAMAQAEFAAPHAACDwQALg82AiRQbT0xfX0=
:: map/blueprints/circle.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTExIDA5OjM5OjI1Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMiAxMzo1Mjo0NCIscmV2aXNpb249MTM0XV1sejQA8wAAAA8FAAD-Dnt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDE0LDEwLCIwAQAqG2QEAAwBABtkBAAEAQAMEAAOAQAPKAADL2QwAQAMDywAGB9kJAAF
DzgAMA4gAA8sABMbZBAADgEADygAAxtkBAAMAQAbZAQADwEAJ-EIIiksaGlkZGVuPWZhbHNlLHBh
bl94PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0shwIKL2MwBAA3DAEAH2MEAAoPAQAP
HmMEAA8BABYXYwQADgEADxwASy9jMAEAFx5jBAAPAQAOH2MEAAwMAQAfYwQANg_HAiRQbT0xfX0=
:: map/blueprints/columns.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTExIDA5OjQ4OjQ0Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMiAxMzo1Mjo0NCIscmV2aXNpb249MTI3XV1sejQACQEAAA8FAAD-Dnt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDE0LDEwLCIwAQAuG2QEAAQBABtkBAAOAQAOHAAPGAANDiAADxgAEw4gAA8YABMOIAAP
GAATDiAADxgAEw4gAA8YABMIHAAEBAAEAQAbZAQADwEAK-EIIiksaGlkZGVuPWZhbHNlLHBhbl94
PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0shwIKL2MwBAAnFzAMAAQEAAQBABtjBAAb
MAwADxAAAQ4YAA8QABMOGAAPEAATDhgADxAAEw4YAA8QABMOGAAPEAATDxgABQgQABtjBAAEAQAb
YwQAFzAMAA8EAB8PhwIkUG09MX19
:: map/blueprints/mega.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTI5IDE0OjU5OjI0Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwODowNzoxOCIscmV2aXNpb249NzU5XV1sejQA5AAAAM8DAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEwAwAvIjABACYTZAQADygAGS9kMAEAIx9kBAAAGzAMAAwBAAgcAC5kMAEACBwAL2Qw
AQAPDCgADAwADAQADwEAI-EIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2
CgAQdwoAj3pvb209MX0s5wEKL2MwBAAXCAEADxQAIQgIAC9jMAEADx9jBAAIFzAMAAQEAAgBAAgU
AAgIAAgMAAQIAAQMAB8wFAAYH2MEAAwIAQAfYwQAFg-nASRQbT0xfX0=
:: map/blueprints/open.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEwIDEyOjUwOjM1Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwOTozODo1NiIscmV2aXNpb249MTldXWx6NADTAAAAzwMAAPAIe3tibXA9dXNlcmRhdGEo
ImkxNiIsMTADAC8iMAEALhNkBAAPQAApDxAACQ4YAA8BADsfZFwAJB5kEAAPFAAEDwEAGfEIIiks
aGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0s5wEKL2Mw
BAAXDwEAAQgcAAgMAA8BAAkIKAAECAAfMBAAABdjEAAvYzABAAceYyAADygABw8UACQfMCQABAAE
ABswDAAbMBQADwQAFw-nASRQbT0xfX0=
:: map/blueprints/spiral.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTExIDA5OjQ0OjQ5Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMiAxMzo1Mjo0NCIscmV2aXNpb249MTMzXV1sejQA5QAAAC8FAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEyAwAvIjABAL4fZAQACA8BAAEPGAAFHzAwADwXZAQADwEACQwgAA8wABEMBAAPAQBX
8QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCPem9vbT0xfSyX
AgovYzAEAB8PAQASDzAAZB9jBAAQCAEAL2MwAQAHH2MgAAAvYzABAAcfYyAAABdjCAAEBAAEAQAM
EAAfMBAADBtjEAAIFAAIBAAEAQAMEAAPAQANH2MEAB4PlwIkUG09MX19
:: map/blueprints/test2.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTI3IDE0OjUwOjM2Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwODowNzoxOCIscmV2aXNpb249MTEzNF1dbHo0AKUAAADKAQAA-w97e2JtcD11c2VyZGF0
YSgiaTE2Iiw2LDYsIjAwMDEEAAgMAQALGAAqZDAYAAUQAA8YABQOBADxByIpLGhpZGRlbj10cnVl
LHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0s5AAIL2MwBAAHDAEADBgAF2MI
AAQEAAgBABdjBAAIAQAfYwQABgbkAE9mYWxz5QAWUG09MX19
:: map/blueprints/test3.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTI5IDE0OjMxOjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwODowNzoxOCIscmV2aXNpb249Nzk1XV1sejQAuQAAAI0CAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEwLDYsIjABABovZDAcABMXZAgABAQADwEADRdkBAAMAQAbZAwAL2QwAQAl8QgiKSxo
aWRkZW49ZmFsc2UscGFuX3g9MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCPem9vbT0xfSxGAQkvYzAE
ABsPAQAFG2MEABcwDAAqYzABAA8UAAkmYzABABdjBAAEAQAMEAAIFAAPBAAPD0YBJFBtPTF9fQ==
:: map/blueprints/test.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTIyIDE0OjA5OjI0Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwODowNzoxOCIscmV2aXNpb249MTQ4Nl1dbHo0ANIAAAB1AgAA-yF7e3RpbGVfaD0xNixw
YW5feD0wLGJtcD11c2VyZGF0YSgiaTE2Iiw5LDYsIjAwMDEEABMiZDAEAA8BAAIHJAAMAQAfZCQA
JC9kMAEABB8xBAARISIp_wDxEXk9MCxoaWRkZW49ZmFsc2UsbmFtZT0ic3ByaXRlcyIsKQEQdykB
j3pvb209MX0sPAEaL2MwBAAcHzEEAAAXMAQAGzEEABcwCAAXMBAACAQAFzAIAAgEAB8xBAAAHzAE
ABEOPAE0dHJ1OwFLbWFzazgBUG09MX19
:: map/blueprints/tutorial.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTA0IDEyOjQ5OjI0Iixtb2RpZmllZD0iMjAyNS0w
Mi0xMSAwODowNzoxOCIscmV2aXNpb249MTc3XV1sejQAkwAAAJoBAAD-DHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDYsNSwiMAEACi9kMCAADA8wABwGAQDxByIpLGhpZGRlbj10cnVlLHBhbl94PTAIANJ5
PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0szAAIL2MwBAALCAEADBQAF2MIAAQEAAgBAB9jBAAG
BswAT2ZhbHPNABZQbT0xfX0=
:: map/blueprints/wed12A.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjM3OjQ1Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249MzA4XV1sejQAtgAAAN0CAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEwLDcsIjABACYvZDAQAA0PAQAjDzgADR9kVABADgEA8QgiKSxoaWRkZW49ZmFsc2Us
cGFuX3g9MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCPem9vbT0xfSxuAQkvYzAEABcIAQAPEAABBAQA
FzAIAA8BAAEfYyAACBtjDAAIEAAfMBAAAAQUAC9jMAEABxdjCAAPBAATD24BJFBtPTF9fQ==
:: map/blueprints/wed12B.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjM4OjU0Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249MzA4XV1sejQA3QAAAL0DAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDE0LDcsIjABAEIfZAQABAgBABdkBAAEAQAfZAQAAg8BAAcfZBgAHA8sAA0fZBwAAAwE
AAQBAC9kMAEAOfEIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoA
j3pvb209MX0s3gEJL2MwBAAnDwEABR9jBAAMFzAMACZjMAEAH2MEAAwMAQAOFAAKGAAXYwwADwEA
BR9jDAAAH2MEAAgEAQAuYzABAB9jBAAmD94BJFBtPTF9fQ==
:: map/blueprints/wed12C.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjQwOjA3Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249MzAzXV1sejQA4gAAAK0EAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDE2LDgsIjABADIXZAQADwEAFRtkDAAMBAAPAQAZCDAAL2QwAQA3HmQEAA8BABofZBAA
DA4YAA8BAAAPNAA4DgEA8QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9MAgA0nk9MCx0aWxlX2g9MTYK
ABB3CgCPem9vbT0xfSxWAgkvYzAEADsPAQAVH2MEAAoPAQATF2MEAAQBAC9jMAEAFx5jMAAPIAAC
CAQACAEADhQACgEAH2MQABAEBAAPAQAdH2MEADIPVgIkUG09MX19
:: map/blueprints/wed12D.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjQxOjQxIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249Mjk4XV1sejQA6gAAAM8DAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEwAwAvIjABABovZDAYAAcvZDABACcbZAQAFzAIAA8BAAIPKAAFDxQAIAgEABcwCAAM
DAAPAQAhH2REAB7xCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xNgoAEHcK
AI96b29tPTF9LOcBCi9jMAQAGw8BAAEbYwQADwEADQwoABtjBAAXMAwAL2MwAQADF2MIAAQEAAQB
AC5jMAEAF2MEAAQBABtjBAAXMAwABAQADwEABg8kABAfYwQAHg-nASRQbT0xfX0=
:: map/blueprints/wed12E.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjQzOjAwIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249Mjk4XV1sejQA4QAAAM8DAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDEwAwAvIjABACYeZAQADwEABhdkCAAvZDABAAcfZAwAEAQQAAgEAA8BAAIPHAAMDiAA
DwEAGA9YAEbxCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0wCADSeT0wLHRpbGVfaD0xNgoAEHcKAI96
b29tPTF9LOcBCi9jMAQAFwgBAB9jBAAIDAEAF2MIAAgEAAwBABtjDAAIBAAIAQAfYwQABAwBAB9j
EAAACBQAL2MwAQADHmMcAA8oABoeYxAADwQAFA-nASRQbT0xfX0=
:: map/blueprints/wed12F.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjQ4OjM4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249Mjk5XV1sejQAigAAAOsCAAD-DHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDksOCwiMAEAii9kMAEAbfEIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGls
ZV9oPTE2CgAQdwoAj3pvb209MX0sdQEIL2MwBAATDwEABg8kAEguYzABAB5jGAAPJAAqDwQACw91
ASRQbT0xfX0=
:: map/blueprints/wed12G.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAyLTEyIDEzOjUxOjM4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249MzAwXV1sejQAzQAAAC0DAAD-DXt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDgsMTAsIjABABIvZDAUAAAPIAAODwEACA8wACAfZCwADC9kMAEAFy9kMAEANfEIIiks
aGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2CgAQdwoAj3pvb209MX0slgEJL2Mw
BAATDAEAG2MEAAwBABdjBAAPAQAFCCAALmMwAQAXYxgABAgAGzAUAAgMAAwBAB9jGAAIBAgAL2Mw
AQAHH2MEAA4PlgEkUG09MX19
:: map/blueprints/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTIyIDE0OjA5OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCJdXQ==
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNC0x
MS0yOSAxNDozMDo0NCIscmV2aXNpb249MzE1MV1dbHo0AIYAAABaAQAA8xN7e2JtcD11c2VyZGF0
YSgiaTE2Iiw4LDgsIjAwYzAwMGMxCAAIBAAIFAAPIAAJHzEEABAOKAAOPAAPBAApHzAEAAQfMQQA
DfEKIiksaGlkZGVuPWZhbHNlLHBhbl94PS0yMAoA8gB5PS0xNSx0aWxlX2g9MTYKABB3CgCAem9v
bT0xfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCIsc3RvcmVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Il1d
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxiZ19jb2xvcj0wLGJsYWNrZXN0X2NvbG9yPTAsY3JlYXRlZD0iMjAyNC0wNC0y
NyAwOTozMToyOSIsaGlkZGVuPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2V9LGhpZGRlbl90b2dnbGVzPXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGxv
Y2tlZD17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNl
LGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZh
bHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxtb2Rp
ZmllZD0iMjAyNS0wMi0xOCAxNDozMToxNSIsb2twYWxfdmVyc2lvbj0iMC4wLjQiLHJldmlzaW9u
PTI4MjMsdGVzdF9jdWJlX2NvbG9ycz17WzBdPXsxNSwzMSw0fSx7MzEsNCwyMH0sezQsMjAsMjF9
LHsxMCw5LDI1fSx7OSwyNSwyNH0sezgsMjQsMn0sezI2LDExLDI3fSx7MTEsMjcsM30sezI3LDMs
MTl9LHsyOCwxNywxOX0sezI4LDEyLDE2fSx7MTIsMTYsMX0sezYsMjksMTN9LHsyOSwxMywxOH0s
ezEzLDE4LDF9LHs3LDIzLDE0fSx7MjMsMTQsMTN9LHsxNCwzMCwxOH0sezcsNiwyMn0sezYsMjIs
NX0sezIyLDUsMjF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9fSx3aGl0ZXN0X2NvbG9yPTddXWx6
NADvAQAAFQIAAPYFdXNlcmRhdGEoImkzMiIsNjQsIjABAPAaZDIwMzAwMGEzMjhiMzAwMTM5ZDA4
MDBhZTZjMzcwMDQxNWQ2NjAwZDcCADEwMGYBAIAwMGUwM2MyOBAAQGJiMzEIACBlNzAAwDU4ZDMz
MjAwNWJhOCgAUTcxYTZhIADwBTgyY2UwMGY1Yjc4NDAwMDI0YWNheQDAOThhYzAwNjI2NGRjkQDw
ATYwNGIwMDgyM2MzZDAwMzQCAPAIMDBjNTk3ODIwMGZlYzllZDAwY2YzYzdYADA2OGZ4APAFOGNk
NjEyMDAyMGI1NjIwMDk4ZGOAAPALOWJhMGVmMDBjYzY5ZTQwMGRhNjU1ZTAwYTgCAEAwMDdiAgBA
MDAxNQIAYDAwYmRmZpgAYDI1ZTJjZJAAEDXnAFAwMDA0ZQYAQDE3MjggAUAzNzZkOQHANmFiNDE3
MDBiZWVikADwBWVlZmZhOTAwYjZjMTIxMDA5Mzk3IABAY2M4ZmAAUGFkNGUxYAAwMzE3sADwAjVj
M2MwZDAwZTJkN2I1MDA0JgCRNzAwZTE4Mjg5WAGgOWM1MDA4NzE2NIgBUDU5Y2ZjMAAgYzngAGBh
Njc1ZmWIACAzMbgAwDVhMTk5MTAwMjExNmcBYDNkMzRhNWgBETgwAIAwMDE3N2QiKQ==
:: pal/amiga-pixels-64.pal
b64$LS1bW3BvZCxva3BhbF92ZXJzaW9uPSIwLjAuNCIsY3JlYXRlZD0iMjAyNC0wNC0yNyAwODo1
OTozNiIsbW9kaWZpZWQ9IjIwMjQtMDUtMDQgMTU6MTU6MjMiLGhpZGRlbl90b2dnbGVzPXtbMF09
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGJsYWNrZXN0X2NvbG9yPTAsbG9ja2VkPXtbMF09ZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LGJnX2NvbG9yPTAsaGlkZGVu
PXtbMF09ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFs
c2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2Us
ZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2V9LHJldmlzaW9u
PTQ4LHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9
LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0s
ezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7
MSwxLDF9LHsxLDEsMX0sezEsMSwxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sd2hpdGVzdF9j
b2xvcj03XV1sejQAAwIAABUCAADwQHVzZXJkYXRhKCJpMzIiLDY0LCIwMDExMTAxMjAwM2IyNDRm
MDA4YTM5NWEwMDM1NzEyZDAwYmU2OTJmMDA1YjU2NWUwMGU2ZTJlNjAwZmQCAPAgMDBmMzUwMzkw
MGZlYTI2YjAwZjllZDI4MDA3Y2FkMTUwMDU1YTVmNjAwNWE1MjcwAEEyYzZmKACQY2E1NDAwMzQ2
NwDgMDUxYTVhNTAwNjYzZjiQAPBeMjY2NjYwMDc3NDExZDAwMzMyZjRjMDA2YTk4OGEwMGZjYjll
YTAwYWEzMTIzMDBiZjk4MWEwMGIwZjc5MzAwNTdiNTQ5MDBhY2YyZmUwMDkzODZjNzAwZDc1ZDky
MDA4YzhhNGIwMDFmMWUxZnAAQDMwMzOAACA2MXgAUDk4OTQ5yADwBGQxYzE0MDA0NjI1MTAwMDc4
NWUIAPANNDczNjA5MDAyYjNlMDcwMDRjNmIwZDAwZGNmNFAAQGU3ZTVAAGE1NzU1MmVgABAxoADw
HTI4MzMxZTAwNDU1YTM0MDA3MDkzNTUwMGQxZWJhYzAwY2FlZGU1MDA0MTVlGABgMjUzNjMxqAAw
NDIx0ADANGYyZjIwMDFjM2IzwABAZTNiOEAAMGNlMegAUDdjODNmsABQYzUwYWKgADAyZTeQAEBi
ZTRmMAHwADU2NmNkMDA1NzIwMzMiKQ==
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI3IDA3OjI4OjMyIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCJdXQ==
:: scripts/
:: scripts/blueprint_library.lua
include("scripts/line_restrictions.lua")

blueprint_library = {
    {
        file_name = "tutorial",
        name = "introduction",
        sell_target = 10,
        power_target = 4,
        popups = {
            {
                x = 330,
                y = 150,
                width = 130,
                content =
                "Once your solution meets the level goals, the button below will turn green. You can click it any time to go back."
            },
            {
                x = 116,
                y = 170,
                width = 300,
                title = "The status bar",
                content =
                "Below you can see the current status for your solution. Your placed tiles' combined cost have to total below the current BUDGET goal, and you have to generate enough POWER to meet the current quota."
            },
            {
                x = 94,
                y = 64,
                title = "The Tiles",
                content =
                "To the left you can find the different tiles you can place. You can place as many as you want, but they each have a cost. Once you select a tile, you LEFT CLICK to place, and RIGHT CLICK, SCROLL or press R to rotate."
            },
            {
                x = 100,
                y = 52,
                width = 100,
                title = "The Toolbar",
                content =
                "Above you can select between the INFO, PLACE, ERASE tools, and the fourth button lets you rotate your currently held tile. They are also assigned to QWER."
            },

            {
                x = 330,
                y = 100,
                width = 100,
                title = "The Canvas",
                content =
                "This is where you place tiles. The gray spaces are already occupied"
            },
            {
                x = 220,
                y = 20,
                title = "Welcome to POWERTILE",
                content =
                "In this game you will place tiles of various shapes on the board. Some generate POWER, while others might have other abilities. (Click a popup to continue)"
            },

        }
    },
    {
        file_name = "test2",
        name = "nano",
        sell_target = 15,
        power_target = 7,
        -- restrictions = {
        -- 	createLineRestriction("col", 2, line_restrictions_lib.exact_power, 1),
        -- 	createLineRestriction("col", 3, line_restrictions_lib.forbidden_type, 1),
        -- }
    },
    {
        file_name = "test",
        name = "plugin",
        sell_target = 14,
        power_target = 8
    },
    {
        file_name = "test3",
        name = "two legs",
        sell_target = 12,
        power_target = 8
    },
    {
        file_name = "wed12F",
        name = "restricted",
        sell_target = 14,
        power_target = 14,
        restrictions = {
            createLineRestriction("row", 4, line_restrictions_lib.exact_power, 1),
            createLineRestriction("col", 6, line_restrictions_lib.exact_power, 3)
        },
        popups = { {
            title = "More tiles...",
            content = "If you have unlocked more tile types than can fit in the box, you can find them on the next page, use the +/- buttons to navigate, or use 123 on your keyboard."
        }, {
            title = "Restrictions",
            content = "Some levels have restrictions! Use the info tool to inspect each restriction."
        } }
    },
    {
        file_name = "mega",
        name = "mega",
        sell_target = 8,
        power_target = 10
    },
    {
        file_name = "wed12A",
        name = "gravel",
        sell_target = 11,
        power_target = 12
    },
    {
        file_name = "butterfly",
        name = "butterfly",
        sell_target = 20,
        power_target = 20,
        restrictions = {
            createLineRestriction("col", 4, line_restrictions_lib.exact_power, 2),
            createLineRestriction("col", 12, line_restrictions_lib.exact_power, 4),
        },
    },
    {
        file_name = "open",
        name = "open space",
        sell_target = 17,
        power_target = 15,
        restrictions = {
            createLineRestriction("row", 3, line_restrictions_lib.exact_power, 0),
            createLineRestriction("row", 6, line_restrictions_lib.exact_power, 0),
            createLineRestriction("row", 8, line_restrictions_lib.exact_power, 1),
        },
    },
    {
        file_name = "wed12B",
        name = "landsquid",
        sell_target = 20,
        power_target = 12
    },
    --[[ 	{
		file_name = "spiral",
		name = "spiral",
		sell_target = 20,
		power_target = 15
	}, ]]



    {
        file_name = "wed12C",
        name = "offshore",
        sell_target = 14,
        power_target = 23,
        restrictions = {
            createLineRestriction("col", 8, line_restrictions_lib.exact_power, 1),
            createLineRestriction("col", 10, line_restrictions_lib.exact_power, 2),
            createLineRestriction("col", 12, line_restrictions_lib.exact_power, 3),
        },
    },
    {
        file_name = "wed12D",
        name = "symbol",
        sell_target = 20,
        power_target = 15
    },

    {
        file_name = "columns",
        name = "columns",
        sell_target = 30,
        power_target = 20,
        restrictions = {
            createLineRestriction("row", 5, line_restrictions_lib.exact_power, 0),
            createLineRestriction("row", 6, line_restrictions_lib.exact_power, 0),
        },
    },
    {
        file_name = "wed12E",
        name = "kite",
        sell_target = 10,
        power_target = 15,
        restrictions = {
            createLineRestriction("col", 3, line_restrictions_lib.exact_power, 5),
            createLineRestriction("col", 8, line_restrictions_lib.exact_power, 0),
            createLineRestriction("row", 8, line_restrictions_lib.exact_power, 3),
        },
    },
    {
        file_name = "wed12G",
        name = "canister",
        sell_target = 10,
        power_target = 15,
        restrictions = {
            createLineRestriction("col", 4, line_restrictions_lib.exact_power, 0),
            createLineRestriction("col", 5, line_restrictions_lib.exact_power, 9),
        },
    },
    {
        file_name = "circle",
        name = "iris",
        sell_target = 20,
        power_target = 25,
        restrictions = {
            createLineRestriction("row", 6, line_restrictions_lib.exact_power, 6),
            createLineRestriction("col", 7, line_restrictions_lib.exact_power, 4),
        },
    },

}

:: scripts/component_library.lua
--[[pod_format="raw",created="2024-05-12 08:42:14",modified="2024-11-29 11:48:20",revision=67]]
component_library = {
    -- must have:
    -- 	sprite
    -- 	collider
    -- optional:
    --	name
    --	info
    --	price
    --	power
    --	ichor
    -- 	max_rot
    -- 	draw(self)
    -- 	onPlace(self) add other unique variables that can be referenced by itself
    -- 	ability_global(self)
    -- 	ability_instance(self)
    {
        name = "Pink",
        info = "Generates 1 power",
        sprite = 7,
        max_rot = 1,
        price = 3,
        power = 1,
        collider = {
            { 1 }
        },
    },
    {
        name = "Pink Discount",
        info = "Reduces the cost of Pink neighbors by 1",
        sprite = 12,
        max_rot = 2,
        price = 0,
        power = 0,
        collider = {
            { 1, 1 }
        },
        onPlace = function(self)
            for i in all(component_types) do
                if i.name == "Pink" then
                    component_types[self.type].basic_type = i.type
                    break
                end
            end
        end,
        ability_instance = function(self)
            for i in all(self.neighbors) do
                local neighbour = getComponentFromCell(i) or { type = 0 } -- placeholder to avoid nil error
                if neighbour.type == component_types[self.type].basic_type then
                    addModifier(neighbour.price_modifiers, { mod = -1, id = self.id })
                end
            end
        end
    },
    {
        name = "Pill",
        info = "Generates 1 power",
        sprite = 20,
        max_rot = 2,
        price = 2,
        power = 1,
        collider = {
            { 1, 1 }
        },
    },
    {
        name = "Long",
        info = "Generates 3 power",
        sprite = 24,
        max_rot = 2,
        price = 5,
        power = 3,
        collider = {
            { 1, 1, 1, 1 }
        },
    },
    {
        type = 3,
        name = "Advanced Discount",
        info = "Reduces component prices of neighbours by 1 for each empty neighbour space",
        sprite = 16,
        max_rot = 4,
        price = 0,
        collider = {
            { 1, 1 },
            { 1, 0 }
        },
        ability_instance = function(self)
            self.empty_neighbor_cells = {}
            for i in all(self.neighbors) do
                if getCanvasVal(i.x, i.y) == 0 then
                    add(self.empty_neighbor_cells, i)
                end
            end
            self.discount_value = #self.empty_neighbor_cells
            for i in all(self.neighbors) do
                local neighbor = getComponentFromCell(i) -- placeholder to avoid nil error
                if neighbor then
                    removeModifier(neighbor.price_modifiers, self.id)
                    addModifier(neighbor.price_modifiers, { mod = -self.discount_value, id = self.id })
                end
            end
        end,
        draw = function(self)
            spr(self.sprite + self.rotations, self.x, self.y)
            for i in all(self.empty_neighbor_cells) do
                local x, y = workbench.canvas.x + ((i.x - 1) * grid_size), workbench.canvas.y + ((i.y - 1) * grid_size)
                spr(3, x, y)
            end
        end
    },
    {
        name = "Ambrosia",
        info = "The 4th placed generates 1 power. The 8th generates 1 ichor.",
        sprite = 4,
        price = 0,
        collider = { { 1 } },
        onPlace = function(self)
            self.sprite_variation = 0
        end,

        draw = function(self)
            spr(self.sprite + self.sprite_variation, self.x, self.y)
        end,
        ability_global = function(self)
            local count = 0
            for i in all(workbench.placed_components) do
                if i.type == self.type then
                    removeModifier(i.power_modifiers, 1000)
                    removeModifier(i.ichor_modifiers, 1000)
                    i.produces_power = false
                    i.produces_ichor = false
                    i.sprite_variation = 0
                    count += 1
                    if workbench.placed_component_amount[self.type] >= 4 and count == 4 then
                        i.sprite_variation = 1
                        i.produces_power = true
                        addModifier(i.power_modifiers, { mod = 1, id = 1000 })
                    elseif workbench.placed_component_amount[self.type] >= 8 and count == 8 then
                        i.sprite_variation = 2
                        i.produces_ichor = true
                        addModifier(i.ichor_modifiers, { mod = 1, id = 1000 })
                    end
                end
            end
        end
    },
    {
        name = "Diversity Engine",
        info = "Generates 1 power per different type of neighbour",
        sprite = 34,
        max_rot = 2,
        price = 5,
        power = 0,
        collider = {
            { 1, 1, 0 },
            { 0, 1, 1 }
        },
        ability_instance = function(self)
            removeModifier(self.power_modifiers, self.id)
            self.produces_power = false
            self.list_of_unique_neighbor_types = {}
            for n in all(self.neighbors) do
                local neighbor = getComponentFromCell(n) -- placeholder to avoid nil error
                if neighbor then
                    local uniquness = true
                    for i in all(self.list_of_unique_neighbor_types) do
                        if neighbor.type == i then
                            uniquness = false
                        end
                    end
                    if uniquness then
                        add(self.list_of_unique_neighbor_types, neighbor.type)
                    end
                end
            end
            local type_count = #self.list_of_unique_neighbor_types or 0
            if type_count > 0 then
                self.produces_power = true
                addModifier(self.power_modifiers, { mod = type_count, id = self.id })
            end
        end
    },
    {
        name = "Impossible Engine",
        info = "Generates 1 ichor",
        sprite = 32,
        price = 3,
        ichor = 1,
        collider = {
            { 1, 1 },
            { 1, 1 }
        },
    },
    {
        name = "Chain",
        info = "Generates one 1 power when connected to 1 or 2 other Chains",
        sprite = 40,
        max_rot = 2,
        price = 1,
        collider = {
            { 1, 1 },
        },
        draw = function(self)
            if self.produces_power then
                pal(0, 10)
            end
            spr(self.sprite + self.rotations, self.x, self.y)
            pal(0, 0)
        end,
        ability_instance = function(self)
            --check if neighbors are the same type, sets power to 1 if so
            self.produces_power = false
            local chain_count = 0
            local chained_ids = {}
            for i in all(self.neighbors) do
                local neighbour = getComponentFromCell(i) or { type = 0 } -- placeholder to avoid nil error
                if neighbour.type == self.type then
                    chained_ids[neighbour.id] = neighbour.id
                end
            end
            for k, v in pairs(chained_ids) do
                chain_count += 1
            end
            if chain_count > 0 and chain_count <= 2 then
                self.produces_power = true
                addModifier(self.power_modifiers, { mod = 1, id = self.id })
            end
            if self.produces_power == false then
                removeModifier(self.power_modifiers, self.id)
            end
        end,

    },
    {
        name = "Frame",
        info = "Generates 6 power",
        sprite = 42,
        price = 8,
        power = 6,
        collider = {
            { 1, 1, 1 },
            { 1, 0, 1 },
            { 1, 1, 1 }
        },

    },
    {
        name = "Booster",
        info = "Boosts the generation of attached component",
        sprite = 43,
        max_rot = 4,
        price = 2,
        collider = { { 1 } },
        draw = function(self)
            local y_offset = 0
            if self.rotations == 2 then y_offset = -2 end
            local x_offset = 0
            if self.rotations == 3 then x_offset = -2 end
            spr(self.sprite + self.rotations, self.x + x_offset, self.y + y_offset)
        end,
        onPlace = function(self)
            self.boosted_neighbour = nil
            for y = 1, workbench.canvas.grid_height do
                for x = 1, workbench.canvas.grid_width do
                    if workbench.canvas.grid[y][x] == self.id then
                        if self.rotations == 0 then     --south
                            self.boosted_neighbour = vec(x, y + 1)
                        elseif self.rotations == 1 then --east
                            self.boosted_neighbour = vec(x + 1, y)
                        elseif self.rotations == 2 then --north
                            self.boosted_neighbour = vec(x, y - 1)
                        elseif self.rotations == 3 then --west
                            self.boosted_neighbour = vec(x - 1, y)
                        end
                    end
                end
            end
            self.ability_instance(self)
        end,
        ability_instance = function(self)
            local id = getCanvasVal(self.boosted_neighbour.x, self.boosted_neighbour.y)
            if id > 1 then
                for i in all(workbench.placed_components) do
                    if i.id == id then
                        addModifier(i.power_modifiers, { mod = 1, id = self.id })
                        addModifier(i.ichor_modifiers, { mod = 1, id = self.id })
                    end
                end
            end
        end,
    },
    {
        name = "Blob",
        info = "Generates 1 ichor",
        sprite = 48,
        max_rot = 2,
        price = 5,
        ichor = 1,
        collider = {
            { 0, 1 },
            { 1, 0 }
        },

    },
    {
        name = "Alone",
        info = "Generates 1 power, reduces power generation of neighbours by 1",
        sprite = 14,
        price = 1,
        power = 1,
        collider = {
            { 1 }
        },
        draw = function(self)
            spr(self.sprite, self.x, self.y)
            for i in all(self.neighbors) do
                if getCanvasVal(i.x, i.y) == 0 then
                    local x, y = workbench.canvas.x + ((i.x - 1) * grid_size),
                        workbench.canvas.y + ((i.y - 1) * grid_size)
                    spr(15, x, y)
                end
            end
        end,
        ability_instance = function(self)
            for i in all(self.neighbors) do
                if getCanvasVal(i.x, i.y) > 1 then
                    local neighbor = getComponentFromCell(i) or {}
                    addModifier(neighbor.power_modifiers, { mod = -1, id = self.id })
                end
            end
        end

    },
    {
        name = "Displaced",
        info = "Generates 2 power",
        sprite = 51,
        max_rot = 4,
        price = 3,
        power = 2,
        collider = {
            { 0, 0, 1 },
            { 1, 1, 0 }
        },
    }
}

function initComponentTypes()
    local types = {}
    for i = 1, #component_library do
        local component_type = componentFromTemplate(i)
        component_type.type = i
        add(types, component_type)
    end
    return types
end

function componentFromTemplate(index)
    local lib_component = tablecopy(component_library[index])
    local component = {
        name = lib_component.name or "Untitled",
        info = lib_component.info or "",
        sprite = lib_component.sprite,
        rotations = 0,
        max_rot = lib_component.max_rot or 1, --default is no rotations
        price = lib_component.price or 0,
        power = lib_component.power or 0,
        ichor = lib_component.ichor or 0,
        collider = lib_component.collider,
        draw = lib_component.draw or function(self)
            spr(self.sprite + self.rotations, self.x, self.y)
        end,
        onPlace = lib_component.onPlace or nil,
        onErase = lib_component.onErase or nil,
        ability_global = lib_component.ability_global or nil,
        ability_instance = lib_component.ability_instance or nil,
    }
    if component.power > 0 then
        component.produces_power = true
    else
        component.produces_power = false
    end
    if component.ichor > 0 then
        component.produces_ichor = true
    else
        component.produces_ichor = false
    end
    component.width = #component.collider[1]
    component.height = #component.collider
    return component
end

-- component_types_experimental = {
-- 	{
-- 		type = 1,
-- 		name = "Combinator",
-- 		info = "Has " ..
-- 			string_color.yellow ..
-- 			"+1" .. string_icon.power .. string_color.green .. " for each \nneighbour of the \nsame type",
-- 		width = 1,
-- 		height = 1,
-- 		sprite = 7,
-- 		rotations = 0,
-- 		max_rot = 1,
-- 		price = 2,
-- 		power = 0,
-- 		ichor = 0,
-- 		collider = { { 1 }
-- 		},
-- 		onPlace = function(self)
-- 			-- self.sprite = self.sprite + ceil(rnd(4))
-- 		end
-- 		,
-- 		draw = function(self)
-- 			spr(self.sprite + self.rotations, self.x, self.y)
-- 			print(self.power, self.x + 6, self.y + 4, 30)
-- 		end,
-- 		ability_instance = function(self) -- gets +1 power if next to the same type
-- 			self.power = 0
-- 			for i in all(self.neighbors) do
-- 				local id = getCanvasVal(i.x, i.y)

-- 				for p in all(workbench.placed_components) do
-- 					if p.id == id and p.type == self.type then
-- 						self.power += 1
-- 					end
-- 				end
-- 			end
-- 		end
-- 	},
-- 	{
-- 		type = 2,
-- 		name = "Battery",
-- 		info = "Generates " .. string_color.yellow .. string_icon.power,
-- 		width = 2,
-- 		height = 1,
-- 		sprite = 14,
-- 		rotations = 0,
-- 		max_rot = 2,
-- 		price = 2,
-- 		power = 2,
-- 		ichor = 0,
-- 		collider = {
-- 			{ 1, 1 }
-- 		},
-- 		draw = function(self)
-- 			spr(self.sprite + self.rotations, self.x, self.y)
-- 		end,
-- 		-- ability_global = function(self)
-- 		-- 	workbench.ichor_generated += placed_component_amount[self.type]
-- 		-- end
-- 	},
-- 	{
-- 		type = 3,
-- 		name = "Discounter",
-- 		info = "Each one reduces \nexpenses by -$1",
-- 		width = 2,
-- 		height = 2,
-- 		sprite = 16,
-- 		rotations = 0,
-- 		max_rot = 4,
-- 		price = -1,
-- 		power = 0,
-- 		ichor = 0,
-- 		collider = {
-- 			{ 1, 1 },
-- 			{ 1, 0 }
-- 		},
-- 		draw = function(self)
-- 			spr(self.sprite + self.rotations, self.x, self.y)
-- 		end
-- 	},
-- 	{
-- 		type = 4,
-- 		name = "Multiplier",
-- 		info = "Generates " ..
-- 			string_color.yellow .. string_icon.power .. string_color.green .. " equal \nto number of my-\nself",
-- 		width = 4,
-- 		height = 1,
-- 		sprite = 24,
-- 		rotations = 0,
-- 		max_rot = 2,
-- 		price = 2,
-- 		power = 0,
-- 		ichor = 0,
-- 		collider = {
-- 			{ 1, 1, 1, 1 }
-- 		},
-- 		draw = function(self)
-- 			spr(self.sprite + self.rotations, self.x, self.y)
-- 		end,
-- 		ability_instance = function(self)
-- 			local count = 0
-- 			for i in all(workbench.placed_components) do
-- 				if i.type == self.type then
-- 					count += 1
-- 				end
-- 			end
-- 			self.power = count
-- 		end
-- 	},
-- 	{
-- 		type = 5,
-- 		name = "ichor-a-byte",
-- 		info = "Generates " .. string_color.blue .. "1" .. string_icon.ichor,
-- 		width = 2,
-- 		height = 2,
-- 		sprite = 32,
-- 		rotations = 0,
-- 		max_rot = 0,
-- 		price = 3,
-- 		power = 0,
-- 		ichor = 1,
-- 		collider = {
-- 			{ 1, 1 },
-- 			{ 1, 1 }
-- 		},
-- 		draw = function(self)
-- 			spr(self.sprite, self.x, self.y)
-- 		end
-- 	}
-- }

:: scripts/game_init.lua
-- for things that need to be set before anything else

game = {}

string_icon = {
    power = "\^:040603060c060200\-d",
    ichor = "\^:040e040602070200\-d"
}
string_color = {
    yellow = "\fa",
    green = "\fb",
    white = "\f7",
    blue = "\fc"
}

:: scripts/generic_draw.lua
function drawDebug()
    local memory = "M:" .. stat(0)
    local cpu = "CPU:" .. flr(stat(1) * 100)
    print(cpu, 480 - 5 * #cpu, 9, stat(1) + 6)
    print(memory, 480 - 5 * #memory, 1, stat(0) + 6)
end

function stringIcon(icon, color, label, label_after, color_reset)
    local color = color or "b"
    local color_reset = color_reset or "b"
    return "\f" .. color .. label .. icon .. label_after .. "\f" .. color_reset
end

function drawCheckerBoard(offset_x, offset_y, grid_w, grid_h, clr, bg_clr, size)
    local grid_size = size or grid_size
    --checkerboard
    rectfill(offset_x, offset_y, offset_x + (grid_w * grid_size) - 1, offset_y + (grid_h * grid_size) - 1, bg_clr)
    for x = 0, grid_w - 1 do
        for y = 0, grid_h - 1 do
            if x % 2 == 0 and y % 2 == 0 or x % 2 ~= 0 and y % 2 ~= 0 then
                rectfill(offset_x + x * grid_size,
                    offset_y + y * grid_size,
                    offset_x + (x * grid_size) + grid_size - 1,
                    offset_y + (y * grid_size) + grid_size - 1,
                    clr
                )
            end
        end
    end
end

function drawWindowMetal(x, y, width, height)
    rectfill(x, y + 8, x + width - 1, y + height - 8, 0)
    --the sprite numbers
    local window_sprites = {
        88, 89, 90,
        96, 97, 98
    }
    rect(x, y + 7, x + width - 1, y + height - 8, 5)
    spr(window_sprites[1], x, y)
    sspr(window_sprites[2], 0, 0, 8, 8, x + 8, y, width - 16, 8)
    spr(window_sprites[3], x + width - 8, y)

    spr(window_sprites[4], x, y + height - 8)
    sspr(window_sprites[5], 0, 0, 8, 8, x + 8, y + height - 8, width - 16, 8)
    spr(window_sprites[6], x + width - 8, y + height - 8)
end

function drawWindowMarble(x, y, width, height)
    rectfill(x, y, x + width - 1, y + height - 1, 33)
    --the sprite numbers
    local window_sprites = {
        105, 106,
        113, 114
    }
    --rect(x,y+7,x+width-1,y+height-8,5)
    sspr(window_sprites[1], 4, 0, 4, 8, x + 8, y, width - 16, 8)
    sspr(window_sprites[1], 0, 4, 8, 4, x, y + 8, 8, height - 8)
    sspr(window_sprites[2], 0, 4, 8, 4, x + width - 8, y + 8, 8, height - 8)
    sspr(window_sprites[3], 4, 0, 4, 8, x + 8, y + height - 8, width - 16, 8)

    spr(window_sprites[1], x, y)
    spr(window_sprites[2], x + width - 8, y)

    spr(window_sprites[3], x, y + height - 8)

    spr(window_sprites[4], x + width - 8, y + height - 8)
end

function drawWindowGlass(x, y, width, height)
    rectfill(x, y, x + width - 1, y + height - 1, 0)
    --the sprite numbers
    local window_sprites = {
        164, 165,
        166, 167
    }
    --rect(x,y+7,x+width-1,y+height-8,5)
    sspr(window_sprites[1], 4, 0, 4, 8, x + 8, y, width - 16, 8)
    sspr(window_sprites[1], 0, 4, 8, 4, x, y + 8, 8, height - 8)
    sspr(window_sprites[2], 0, 4, 8, 4, x + width - 8, y + 8, 8, height - 8)
    sspr(window_sprites[3], 4, 0, 4, 8, x + 8, y + height - 8, width - 16, 8)

    spr(window_sprites[1], x, y)
    spr(window_sprites[2], x + width - 8, y)

    spr(window_sprites[3], x, y + height - 8)

    spr(window_sprites[4], x + width - 8, y + height - 8)
end

function drawPillButton(x, y, width, hover, clicked, label)
    width = max(16, width)
    if clicked then
        sspr(159, 0, 0, 4, 16, x + 8, y, width - 16, 16)
        spr(157, x, y)             --left corner
        spr(158, x + width - 8, y) --right corner
    else
        sspr(151, 0, 0, 4, 16, x + 8, y, width - 16, 16)
        spr(149, x, y)             --left corner
        spr(150, x + width - 8, y) --right corner
    end
    if label then
        if clicked then y += 1 end
        print(label, x + 6, y + 4, 0)
        local color = 7
        if hover and clicked == false then color = 14 end
        print(label, x + 6, y + 3, color)
    end
end

function drawGetInfo(title, text, x, y, w)
    local width = w or 100
    local height = 16
    local longest_text = max(#title * 6, #text * 6)
    if longest_text < width then width = longest_text end
    local text_formatted, text_height = textwrap(text, width - 4)
    height += text_height


    x = mid(0, x, 474 - width)
    y = mid(0, y, 264 - height)

    --[[  rectfill(x + 2, y + 2, x + width + 2, y + height + 2, 1)
    rectfill(x, y, x + width, y + height, 39)
    rect(x, y, x + width, y + height, 38)
    ) ]]
    drawWindowGlass(x, y, width, height)
    rectfill(x + 1, y + 1, x + width - 2, y + 9, 37)
    print(title, x + 3, y + 2, 35)
    print(text_formatted, x + 3, y + 12, 17)
    return height --returns the calculated height
end

function drawComponentInfo(i, x, y, w)
    local w = w or 100
    local calculated_height = drawGetInfo(i.name, i.info, x, y, w)
    local y = y - 3
    local x = x + 1
    if i.produces_power then
        local string_for_calc = "$" .. i.price .. "#" .. i.power
        local calculated_width = #string_for_calc * 6
        drawWindowMetal(x, y + calculated_height, calculated_width + 6, 14)
        local str = "$" .. i.price
        local x2 = print(str, x + 4, y + 3 + calculated_height, 11)
        local str = string_icon.power .. i.power
        print(str, x2 + 2, y + 3 + calculated_height, 10)
    elseif i.produces_ichor then
        local string_for_calc = "$" .. i.price .. "#" .. i.ichor
        local calculated_width = #string_for_calc * 6
        drawWindowMetal(x, y + calculated_height, calculated_width + 6, 14)
        local str = "$" .. i.price
        local x2 = print(str, x + 4, y + 3 + calculated_height, 11)
        local str = string_icon.ichor .. i.ichor
        print(str, x2 + 2, y + 3 + calculated_height, 62)
    else
        local string_for_calc = "$" .. i.price
        local calculated_width = #string_for_calc * 6
        drawWindowMetal(x, y + calculated_height, calculated_width + 6, 14)
        local str = "$" .. i.price
        print(str, x + 4, y + 3 + calculated_height, 11)
    end
end

function horizontalCenter(s, middle) -- from pico 8 wiki
    -- screen center minus the
    -- string length times the
    -- pixels in a char's width,
    -- cut in half
    return middle - #s * 2
end

--from rosetta code, added conversion from line width in characters to pixels, and returns number of height of text in pixels
function splittokens(s)
    local res = {}
    for w in s:gmatch("%S+") do
        res[#res + 1] = w
    end
    return res
end

function textwrap(text, width_in_pixels)
    linewidth = width_in_pixels / 5
    local spaceleft = linewidth
    local res = {}
    local line = {}

    for _, word in ipairs(splittokens(text)) do
        if #word + 1 > spaceleft then
            table.insert(res, table.concat(line, ' '))
            line = { word }
            spaceleft = linewidth - #word
        else
            table.insert(line, word)
            spaceleft = spaceleft - (#word + 1)
        end
    end

    table.insert(res, table.concat(line, ' '))
    return table.concat(res, '\n'), #res * 11
end

:: scripts/helpers.lua
--[[pod_format="raw",created="2024-05-12 07:37:40",modified="2024-05-12 09:16:38",revision=83]]
function every(duration, offset, period)
    local frames = flr(time() * 60)
    local offset = offset or 0
    local period = period or 1
    local offset_frames = frames + offset
    return offset_frames % duration < period
end

function lerp(a, b, t)
    return a + t * (b - a)
end

function getComponentFromCell(cell)
    local id = getCanvasVal(cell.x, cell.y)

    if id > 1 then
        for i in all(workbench.placed_components) do
            if i.id == id then
                return i
            end
        end
    end
    return nil
end

function tableContainsVal(table, value)
    for y = 1, #table do
        if count(table[y], value) > 0 then
            return true
        end
    end
    return nil
end

function init2dTable(w, h, val)
    local val = val or 0
    local table = {}
    for y = 1, h do
        table[y] = {}
        for x = 1, w do
            table[y][x] = val
        end
    end
    return table
end

function rotateMatrix(m)
    local rotated = {}
    for c, m_1_c in ipairs(m[1]) do
        local col = { m_1_c }
        for r = 2, #m do
            col[r] = m[r][c]
        end
        table.insert(rotated, 1, col)
    end
    return rotated
end

--helper function to copy a whole table (recursively)
function tablecopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[tablecopy(orig_key)] = tablecopy(orig_value)
        end
        setmetatable(copy, tablecopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function updateMouse()
    mbtn_update()
    mouse_val.x, mouse_val.y, mouse_val.button, mouse_val.wheel_x, mouse_val.wheel_y = mouse()
end

function mouseWithinRect(x, y, w, h)
    if mouse_val.x > x
        and mouse_val.x < x + w
        and mouse_val.y > y
        and mouse_val.y < y + h then
        return true
    else
        return false
    end
end

function alignCenter(object_length, rectangle_length)
    return flr((rectangle_length / 2) - (object_length / 2))
end

function toggle(bool)
    if bool then
        return false
    else
        return true
    end
end

function removeDuplicateNeighbors(tbl)
    local dictionary = {}
    for a in all(tbl) do
        dictionary[a.x .. "," .. a.y] = a
    end

    local result = {}
    for k, v in pairs(dictionary) do
        add(result, v)
    end

    return result
end

:: scripts/level_select_draw.lua
--[[pod_format="raw",created="2024-12-03 10:50:52",modified="2024-12-03 10:50:52",revision=0]]

function drawLevelSelect()
    drawCheckerBoard(-8, -8, 21, 12, 21, 34, 24)
    drawGetInfo("How-to", welcome_message, 14, 80, 168)

    --print(level_page + 1, 16, 250)
    spr(184, 14, 18) -- logo
    print("a puzzle game prototype \nby catnipped \ndedicated to yoko the cat", 16, 40, 6)

    -- progression stats

    local prog_x = 16
    local prog_y = 245
    drawWindowMetal(prog_x - 4, prog_y - 8, 100, 25)
    spr(91, prog_x, prog_y - 4)
    print(progression.cleared_amount .. "/" .. #blueprint_library, prog_x + 20, prog_y, 7)
    prog_x = prog_x + 48
    pal(3, 16)
    pal(11, 62)
    spr(91, prog_x, prog_y - 4)
    pal(3, 3)
    pal(11, 11)
    print(progression.cleared_with_blue_amount .. "/" .. #blueprint_library, prog_x + 20, prog_y, 7)

    drawLevelButtons(level_buttons)
end

function drawLevelButtons(buttons)
    for b in all(buttons) do
        b.draw(b)
    end
end

function drawBlueprintFile(x, y, level_number, hover, selected)
    if hover then
        rectfill(x - 7, y - 3, x + 37, y + 41, 0)
    end
    if progression.blueprints[level_number].unlocked then
        spr(160, x - 4, y)
        print(level_number, x + 18, y + 3, 36)
        local bp = blueprint_library[level_number]
        local sell_target = bp.sell_target
        local power_target = bp.power_target
        if progression.blueprints[level_number].clear then
            sell_target = progression.blueprints[level_number].cost_of_components .. "/" .. sell_target
            power_target = progression.blueprints[level_number].power_generated .. "/" .. power_target
        end
        print(sell_target, x + 6, y + 15, 11)
        print(power_target, x + 6, y + 29, 9)

        local name_colors = { 0, 7 }
        if selected then name_colors = { 7, 0 } end
        rectfill(horizontalCenter(bp.name, x + 10) - 2, y + 44, horizontalCenter(bp.name, x + 10) + #bp.name * 5 + 2,
            y + 53, name_colors[1])
        print(bp.name, horizontalCenter(bp.name, x + 10), y + 45, name_colors[2])

        --checkmark
        if progression.blueprints[level_number].clear_with_blue then
            spr(99, x - 7, y - 3)
            print(progression.blueprints[level_number].ichor_generated, x - 1, y + 2, 62)
            print(progression.blueprints[level_number].ichor_generated, x - 1, y + 1, 7)
        elseif progression.blueprints[level_number].clear then
            spr(91, x - 7, y - 3)
        end
    else -- if not unlocked
        spr(161, x - 4, y)
    end
end

:: scripts/level_select_init.lua
function initLevelSelect()
    buttons = {}
    popups = {}
    level_buttons = {}
    window { cursor = 1 }

    welcome_message =
    "Hi! The goal is to place tiles, generating enough POWER to reach the quota while staying under BUDGET. See if you can get some ICHOR as well... Click a level file to start."

    -- list of blueprint select buttons
    local level_select_width = 4
    for i = 1, #blueprint_library do
        local y_offset = (flr((i - 1) / level_select_width) * 64)
        local x_offset = ((i - 1) % level_select_width) * 64
        local level_button = createButton(208 + x_offset, 14 + y_offset, 42, 42)
        level_button.draw = function(self)
            drawBlueprintFile(self.x, self.y + self.y_offset, i, self.hover, self.selected)
        end
        level_button.onClick = function(self)
            if self.selected and progression.blueprints[i].unlocked then
                current_screen = "workbench"
                initWorkbench(i)
            end
        end

        add(level_buttons, level_button)
    end

    --pagination
    level_page = 0
    local page_count = flr(#blueprint_library / (level_select_width * 4))
    local page_up = createButton(16, 216, 16, 16)
    page_up.draw = function(self)
        drawPillButton(self.x, self.y, self.width, self.hover, self.clicked, "<")
    end
    page_up.onClick = function(self)
        level_page -= 1
        level_page = mid(0, level_page, page_count)
    end
    --add(buttons, page_up)

    local page_down = createButton(36, 216, 16, 16)
    page_down.draw = function(self)
        drawPillButton(self.x, self.y, self.width, self.hover, self.clicked, ">")
    end
    page_down.onClick = function(self)
        level_page += 1
        level_page = mid(0, level_page, page_count)
    end
    --add(buttons, page_down)

    checkComponentUnlock()
end

function checkComponentUnlock()
    while progression.components_unlocks < flr(progression.cleared_amount / 1)
        and progression.components_starting_unlocks + progression.components_unlocks < #component_types
    do
        progression.components_unlocks += 1

        --make a popup!
        local unlock_pop = createButton(alignCenter(190, 480), alignCenter(100, 270), 190, 100)
        local component_nr = progression.components_starting_unlocks + progression.components_unlocks
        unlock_pop.draw = function(self)
            drawWindowMetal(self.x, self.y, self.width, self.height)

            print("You unlocked a new component!", self.x + 8, self.y + 8, 11)
            drawComponentInfo(component_types[component_nr], self.x + 80, self.y + 24)
            drawCheckerBoard(self.x + 8, self.y + 24, component_types[component_nr].width,
                component_types[component_nr].height, 38, 39)
            spr(component_types[component_nr].sprite, self.x + 8, self.y + 24)
        end
        unlock_pop.onClick = function(self)
            del(popups, self)
        end

        add(popups, unlock_pop)
    end
end

:: scripts/level_select_update.lua
function updateLevelSelect()
	if #popups < 1 then
	
		for b in all(level_buttons) do
            buttonUpdate(b)
			b.y_offset = lerp(b.y_offset, -256 * level_page, 0.07)
			-- b.y_offset = flr(b.y_offset)
		end
	end
end

:: scripts/line_restrictions.lua
--[[pod_format="raw",created="2024-12-10 16:33:43",modified="2024-12-10 16:37:23",revision=2]]
line_restrictions_lib = {
    exact_power = {
        description = "power value in \nthis row/column \nmust equal X",
        eval_fun = function(self)
            local power = 0
            local list_of_ids = {}
            for i in all(self.cells) do
                local comp = getComponentFromCell(i)
                if comp ~= nil then
                    --to make sure we don't count the same component twice
                    local have_i_counted_before = false
                    for id in all(list_of_ids) do
                        if comp.id == id then
                            have_i_counted_before = true
                        end
                    end
                    if have_i_counted_before == false and comp.produces_power then
                        power += (comp.power)
                        add(list_of_ids, comp.id)
                    end
                end
            end

            return power == self.value
        end,
        draw_fun = function(self)
            drawLineRestrictionIcon(self.line_type, self.index, 176, self.check, self.description, self.value)
        end

    },
    forbidden_type = {
        description = "no components of \nthis type allowed",
        eval_fun = function(self)
            local clean = true
            for i in all(self.cells) do
                local comp = getComponentFromCell(i)

                if comp ~= nil then
                    if comp.type == self.value then clean = false end
                end
            end
            return clean
        end,
        draw_fun = function(self)
            drawLineRestrictionIcon(self.line_type, self.index, 178, self.check, self.description)
        end
    }
}

function createLineRestriction(line_type, index, restriction_type, value)
    local restriction = {
        check = false,
        line_type = line_type,
        index = index,
        value = value,
        description = restriction_type.description,
        eval_fun = restriction_type.eval_fun,
        draw_fun = restriction_type.draw_fun
    }
    return restriction
end

:: scripts/progression.lua
--[[pod_format="raw",created="2024-12-17 11:40:19",modified="2024-12-17 11:40:37",revision=1]]
function initProgression(bp_lib)
    cheat = false
    local table = {
        cleared_amount = 0,
        cleared_with_blue_amount = 0,
        blueprints_starting_unlocks = 3,
        blueprints = {},
        components_starting_unlocks = 3,
        components_unlocks = 0
    }
    if cheat then
        table.blueprints_starting_unlocks = #bp_lib
        table.components_starting_unlocks = #component_library
    end
    for i = 1, #bp_lib do
        table.blueprints[i] = {
            unlocked = false,
            clear = false,
            clear_with_blue = false,
        }
    end
    return table
end

function updateLevelProgression()
    progression.cleared_amount = 0
    progression.cleared_with_blue_amount = 0
    for i = 1, #progression.blueprints do
        if progression.blueprints[i].clear then
            progression.cleared_amount += 1
        end
        if progression.blueprints[i].clear_with_blue then
            progression.cleared_with_blue_amount += 1
        end
        if i <= progression.blueprints_starting_unlocks + progression.cleared_amount then
            progression.blueprints[i].unlocked = true
        end
    end
end

function saveProgression()
    updateLevelProgression()
    store("/appdata/powertile/progression.pod", progression)
end

:: scripts/ui.lua
function buttonUpdate(b)
    b.clicked = false
    if mouseWithinRect(b.x + b.x_offset, b.y + b.y_offset, b.width, b.height) and b.visible then
        b.hover = true
        b.onHover(b)
        if mbtnp(0) then
            b.onClick(b)
            b.selected = true
        end
        if mbtn(0) then
            b.clicked = true
        end
    else
        b.hover = false
    end
    if not mouseWithinRect(b.x + b.x_offset, b.y + b.y_offset, b.width, b.height) and mbtnp(0) then
        b.selected = false
    end
end

function createButton(x, y, width, height)
    local button = {
        x = x,
        y = y,
        x_offset = 0,
        y_offset = 0,
        width = width,
        height = height,
        visible = true,
        hover = false,
        selected = false,
        onClick = function(self)
        end,
        onHover = function(self)
        end,
        draw = function(self)
        end
    }
    return button
end


:: scripts/workbench_draw.lua
--[[pod_format="raw",created="2024-05-12 07:45:28",modified="2024-11-27 14:19:37",revision=94]]
function drawWorkbench()
    drawCheckerBoard(-8,-8,21,12,21,34,24)
    drawCanvas(workbench.canvas)
    drawLineRestrictions()
    drawComponentBox(8, 8, 82, 254)
    drawToolbox(98, 8, 82, 42)
    drawTotal(98, 237)

    --draws the component under the mouse if one is held

    if mouse_mode[2] then
        cursor.draw = function()
            spr(workbench.held_component.sprite + workbench.held_component.rotations, mouse_val.x - 4,
                mouse_val.y - 4)
        end
        drawComponentInfo(workbench.held_component, 98 + 82 + 8, 12, 200)
    end
    if mouse_mode[1] and tooltip then
        cursor.draw = function()
            drawComponentInfo(tooltip, mouse_val.x + 6, mouse_val.y)
        end
    end
    drawLevelInfo(428, 220)
end

function drawLevelInfo(x, y)
    local str = "\#1" .. "level:" .. blueprint.name
    print(str, x - (#str * 5), y, 17)
end

function drawCanvas(canvas)
    local offset_x, offset_y = canvas.x + grid_size, canvas.y + grid_size

    rectfill(
        offset_x - 4,
        offset_y - 4,
        offset_x + ((canvas.grid_width - 2) * grid_size) + 3,
        offset_y + ((canvas.grid_height - 2) * grid_size) + 3,
        40
    )
    drawCheckerBoard(offset_x, offset_y, canvas.grid_width - 2, canvas.grid_height - 2, 40, 38)
    --rounded corners
    spr(144, offset_x - 4, offset_y - 4)
    spr(145, offset_x + ((canvas.grid_width - 2) * grid_size) - 4, offset_y - 4)
    spr(152, offset_x - 4, offset_y + ((canvas.grid_height - 2) * grid_size) - 4)
    spr(153, offset_x + ((canvas.grid_width - 2) * grid_size) - 4, offset_y + ((canvas.grid_height - 2) * grid_size) - 4)

    drawBlueprint(offset_x, offset_y)

    drawPlacedComponents(workbench.placed_components)
    if show_values then
        drawPlacedValues(workbench.placed_components)
    end
    drawPlacementPreview()
end

function drawPlacedValues(components)
    for i in all(components) do
        if i.produces_power then
            local str = string_icon.power .. i.power
            rectfill(i.x + 3, i.y + 3, i.x + 13, i.y + 11, 0)
            print(str,
                i.x + 4,
                i.y + 4,
                10
            )
        elseif i.produces_ichor then
            local string = string_icon.ichor .. i.ichor
            rectfill(i.x + 3, i.y + 3, i.x + 13, i.y + 11, 0)
            print(string,
                i.x + 4,
                i.y + 4,
                62
            )
        end
    end
end

function drawPlacementPreview()
    if proposed_placement and mouse_mode[2] then
        for x = 1, workbench.canvas.grid_width - 2 do
            for y = 1, workbench.canvas.grid_height - 2 do
                local cell = proposed_placement.collider[y + 1][x + 1]

                if cell > 0 then
                    local color = 7
                    if cell == 2 then
                        color = 8
                    elseif can_place == false then
                        color = 32
                    end
                    pal(7, color)
                    spr(0, workbench.canvas.x + x * grid_size, workbench.canvas.y + y * grid_size)
                    --	print(held_component_id,offset_x+x*grid_size,offset_y+y*grid_size,18)
                end
            end
        end
        pal(7, 7)
    end
end

function drawBlueprint(x, y)
    map(blueprint.canvas.bitmap[1].bmp, 1, 1, x, y, workbench.canvas.grid_width - 2, workbench.canvas.grid_height - 2)
end

function drawPlacedComponents(placed_components)
    for i in all(placed_components) do
        component_types[i.type].draw(i)
    end
end

function drawTotal(x, y)
    drawWindowMetal(x, y, 372, 25)

    --costs
    local cost = "" .. max(flr(workbench.cost_of_components), 0)
    local sell_target = "" .. workbench.sell_target
    local cost_x = x + 7
    local cost_y = y + 3
    line(cost_x - 2, cost_y, cost_x - 2, cost_y + 17, 39)
    spr(75, cost_x, cost_y)
    if workbench.cost_of_components > workbench.sell_target then
        pal(11, 8)
        pal(38, 54)
        pal(39, 51)
        spr(155, cost_x, cost_y + 13)
    end
    for i = 1, #cost do
        local nr = 0 .. sub(cost, i, i)
        spr(65 + nr, cost_x + (7 * i), cost_y)
    end

    spr(78, cost_x + ((#cost + 1) * 7), cost_y)
    for i = 1, #sell_target do
        local nr = 0 .. sub(sell_target, i, i)
        spr(65 + nr, cost_x + ((#cost + 1) * 7) + (7 * i), cost_y)
    end

    pal(11, 10)
    pal(38, 49)
    pal(39, 48)

    --power
    local power = "" .. flr(workbench.power_generated)
    local power_target = "" .. workbench.power_target
    local power_x = cost_x + 70
    local power_y = cost_y
    line(power_x - 2, power_y, power_x - 2, power_y + 17, 39)
    spr(77, power_x, power_y)
    if workbench.power_generated < workbench.power_target then
        pal(11, 8)
        pal(38, 54)
        pal(39, 51)
        spr(154, power_x, power_y + 13)
    end
    for i = 1, #power do
        local nr = 0 .. sub(power, i, i)
        spr(65 + nr, power_x + (7 * i), power_y)
    end


    spr(78, power_x + ((#power + 1) * 7), power_y)
    for i = 1, #power_target do
        local nr = 0 .. sub(power_target, i, i)
        spr(65 + nr, power_x + ((#power + 1) * 7) + (7 * i), power_y)
    end


    -- ichor resource
    local ichor = "" .. flr(workbench.ichor_generated)
    local ichor_x = power_x + 70
    local ichor_y = power_y

    pal(11, 62)
    pal(38, 16)
    pal(39, 63)
    line(ichor_x - 2, ichor_y, ichor_x - 2, ichor_y + 17, 39)
    spr(79, ichor_x, ichor_y)
    for i = 1, #ichor do
        local nr = 0 .. sub(ichor, i, i)
        spr(65 + nr, ichor_x + (7 * i), ichor_y)
    end

    --restrictions
    if blueprint.restrictions then
        pal(11, 7)
        pal(38, 5)
        pal(39, 1)
        local rest_number = 0
        for r in all(blueprint.restrictions) do
            if r.check then
                rest_number += 1
            end
        end
        local rest_string = "" .. flr(rest_number)
        local rest_target = "" .. flr(#blueprint.restrictions)
        local rest_x = ichor_x + 24
        local rest_y = ichor_y
        line(rest_x - 2, rest_y, rest_x - 2, rest_y + 17, 39)
        spr(162, rest_x, rest_y)
        if #blueprint.restrictions > rest_number then
            pal(11, 8)
            pal(38, 54)
            pal(39, 51)
        end
        for i = 1, #rest_string do
            local nr = 0 .. sub(rest_string, i, i)
            spr(65 + nr, rest_x + (7 * i), rest_y)
        end
        spr(78, rest_x + ((#rest_string + 1) * 7), rest_y)
        for i = 1, #rest_target do
            local nr = 0 .. sub(rest_target, i, i)
            spr(65 + nr, rest_x + ((#rest_string + 1) * 7) + (7 * i), rest_y)
        end
    end


    --reset colors
    pal(38, 38)
    pal(39, 39)
    pal(11, 11)

    local used_space_str = "used space:" .. workbench.used_spaces_count .. "/" .. workbench.canvas.space_count
    print(used_space_str, x + 369 - (#used_space_str * 5), y + 8, 32)
end

function drawComponentBox(x, y, width, height)
    drawWindowMetal(x, y, width, height)

    local x, y = x + 5, y + 5
    spr(142, x, y)
    spr(128 + component_buttons.page, x + 24, y)
    spr(143, x + 29, y)
    spr(128 + component_buttons.page_max, x + 35, y)

    for b in all(component_buttons.buttons) do
        if b.visible then
            b.draw(b)
        end
    end
end

function drawComponentInBox(i, x, y, w)
    local h = component_types[i].height * grid_size
    local info_string = workbench.placed_component_amount[i] .. " x " .. "$" .. component_types[i].price
    drawCheckerBoard(x + 4, y, component_types[i].width, component_types[i].height, 38, 39)
    spr(component_types[i].sprite, x + 4, y)

    --spr(111, x - 1, y)
    --pal(11, 39)
    --spr(128 + i, x, y + 1)
    --pal(11, 11)
    print(info_string, 1 + x + w - (#info_string * 5), y + h + 2, 40)
    line(x, y + h + 11, x + w, y + h + 11, 40)
end

function drawToolbox(x, y, width, height)
    drawWindowMetal(x, y, width, height)
    local current_tool = nil
    if mouse_mode[1] then
        current_tool = "Info"
    elseif mouse_mode[2] then
        current_tool = "Place"
    elseif mouse_mode[4] then
        current_tool = "Erase"
    end
    print("Tool:" .. current_tool, x + 3, y + 5, 11)
end

function drawToolButton(x, y, sprite, mode, key)
    local button_sprite = 102
    if mode then button_sprite = 104 end
    spr(button_sprite, x, y)
    if mode then
        pal(11, 39)
        pal(39, 11)
    end
    spr(sprite, x + 4, y + 4)
    pal(11, 11)
    pal(39, 39)
    spr(key, x, y + 17)
    --print(key,x-1,y+15,11)
end

function drawLineRestrictions()
    for r in all(blueprint.restrictions) do
        r.draw_fun(r)
    end
end

function drawLineRestrictionIcon(line_type, index, sprite, check, description, value)
    local pos = vec(workbench.canvas.x, workbench.canvas.y)
    if line_type == "col" then
        pos.x = pos.x + ((index - 1) * grid_size)
        pos.y = pos.y - 6
    end
    if line_type == "row" then
        pos.y = pos.y + ((index - 1) * grid_size)
        pos.x = pos.x - 6
    end
    spr(168, pos.x, pos.y)
    spr(sprite, pos.x, pos.y)
    if value then
        print(value, pos.x + 8, pos.y + 4, 10)
    end
    if check then
        spr(169, pos.x + 10, pos.y + 12)
    end
    if mouseWithinRect(pos.x, pos.y, 16, 16) then
        cursor.draw = function()
            drawGetInfo("Restriction", description, mouse_val.x + 6, mouse_val.y)
        end
    end
end

:: scripts/workbench_init.lua
--[[pod_format="raw",created="2024-05-12 07:41:09",modified="2024-12-17 11:41:37",revision=77]]
function initWorkbench(level_number)
	--load the data for the level (blueprint)
	current_level = level_number
	blueprint = blueprint_library[level_number]
	blueprint.ready = false
	blueprint.canvas = setupBlueprint(blueprint.file_name)
	initLineRestrictions(blueprint.restrictions, blueprint.canvas.bitmap[2].bmp)

	-- set up workbench (current solution)
	printh("loading... " .. "/appdata/powertile/blueprint_solutions/" .. blueprint.file_name .. ".pod")
	workbench = fetch("/appdata/powertile/blueprint_solutions/" .. blueprint.file_name .. ".pod")
	if workbench != nil then
		for i in all(workbench.placed_components) do -- add back ability functions
			if component_types[i.type].ability_instance then
				i.ability_instance = component_types[i.type].ability_instance
			end
			if component_types[i.type].ability_global then
				i.ability_global = component_types[i.type].ability_global
			end
		end
	elseif workbench == nil then
		printh("initiating workbench from scratch")
		workbench = {}
		workbench.canvas = initCanvas()
		--table that holds all globals
		workbench.global_abilities = {}

		--placed components is a list of every saved component and their position
		workbench.placed_components = {}
		workbench.placed_component_amount = countComponents(workbench.placed_components)
		--stats
		workbench.cost_of_components = 0
		workbench.costs_modifiers = {}
		workbench.power_generated = 0
		workbench.power_generated_modifiers = {}
		workbench.ichor_generated = 0
		workbench.ichor_generated_modifiers = {}
		workbench.power_target = blueprint.power_target
		workbench.power_target_modifiers = {}
		workbench.sell_target = blueprint.sell_target
		workbench.sell_target_modifiers = {}
		workbench.restrictions = false
		workbench.used_spaces_count = 0
		if blueprint.popups then
			printh("adding popups")
			printh(#blueprint.popups)
			for p in all(blueprint.popups) do
				local title = p.title or nil
				local x = p.x or nil
				local y = p.y or nil
				local width = p.width or nil
				addTutorialPopup(p.content, title, x, y, width)
			end
		end
		--instances a component from the library and gives it an id
		workbench.held_component = tablecopy(component_types[1])
		workbench.held_component_id = 2 --starts on 2, because 1 is reserved for marked empty
	end
	--these two are used to evaluate and visualise if a component can be placed
	proposed_placement = nil
	can_place = false

	mouse_mode = { false, false, false, false } -- info, place, empty, erase
	mouseMode(1)

	--show component values on canvas flag
	show_values = false

	buttons = {}
	initGoBackButton()
	initToolboxButtons(103, 23)
	component_buttons = {
		buttons = {},
		page = 1,
		page_max = 1
	}
	initComponentBoxButtons(12, 12)
	evaluationUpdate()
	evaluationUpdate()
end

function initGoBackButton()
	local goBack_button = createButton(480 - 54, 216, 36, 16)
	goBack_button.draw = function(self)
		local color = 2
		if workbench.ready then color = 11 end
		if self.hover then color = 7 end
		drawPillButton(self.x, self.y, self.width, self.hover, self.clicked)

		if not workbench.ready then
			if self.hover then
				pal(11, 8)
				pal(38, 0)
			else
				pal(11, 51)
				pal(38, 0)
			end
			spr(86, self.x + 2, self.y + 2)
			pal(38, 38)
			pal(11, 11)
		else
			if not self.hover then
				if every(120, 0, 30) then
					pal(11, 38)
					pal(38, 00)
				end
			end
			spr(86, self.x + 2, self.y + 2)
			pal(38, 38)
			pal(11, 11)
		end
	end
	goBack_button.onClick = function(self)
		if workbench.ready then
			progression.blueprints[current_level].clear = true
			if workbench.ichor_generated > 0 then
				progression.blueprints[current_level].clear_with_blue = true
			end
			progression.blueprints[current_level].power_generated = workbench.power_generated
			progression.blueprints[current_level].ichor_generated = workbench.ichor_generated
			progression.blueprints[current_level].cost_of_components = workbench.cost_of_components
		end
		--saving
		printh("saving...")
		saveProgression()

		store("/appdata/powertile/blueprint_solutions/" .. blueprint.file_name .. ".pod", workbench)

		--switch screens
		current_screen = "level select"
		initLevelSelect()
	end
	add(buttons, goBack_button)
end

function initToolboxButtons(x, y)
	local info_button = createButton(x, y, 16, 16)
	info_button.draw = function(self)
		local selected = false
		if mouse_mode[1] or self.hover then
			selected = true
		end
		drawToolButton(self.x, self.y - 1, 115, selected, 124)
	end

	info_button.onClick = function(self)
		mouseMode(1)
	end

	add(buttons, info_button)

	local place_button = createButton(x + 19, y, 16, 16)
	place_button.draw = function(self)
		local selected = false
		if mouse_mode[2] or self.hover then
			selected = true
		end
		drawToolButton(self.x, self.y - 1, 118, selected, 125)
	end

	place_button.onClick = function(self)
		mouseMode(2)
	end
	add(buttons, place_button)

	local erase_button = createButton(x + 38, y, 16, 16)
	erase_button.draw = function(self)
		local selected = false
		if mouse_mode[4] or self.hover then
			selected = true
		end
		drawToolButton(self.x, self.y - 1, 116, selected, 126)
	end

	erase_button.onClick = function(self)
		mouseMode(4)
	end
	add(buttons, erase_button)

	local rotate_button = createButton(x + 57, y, 16, 16)
	rotate_button.draw = function(self)
		local selected = false
		if self.hover then
			selected = true
		end
		drawToolButton(self.x, self.y - 1, 119, selected, 127)
	end

	rotate_button.onClick = function(self)
		rotateComponent(workbench.held_component)
	end
	add(buttons, rotate_button)
end

function initComponentBoxButtons(x, y)
	local y_offset = 0
	local page_count = 1
	local unlocks = min(#component_types, (progression.components_starting_unlocks + progression.components_unlocks))
	for i = 1, unlocks do
		local component_button = createButton(x, y + 10 + y_offset, 73, component_types[i].height * grid_size)
		component_button.draw = function(self)
			if self.visible then
				if self.hover then
					rectfill(self.x, self.y - 1, self.x + self.width, self.y + self.height, 39)
				end
				drawComponentInBox(i, self.x, self.y, self.width)
			end
		end
		component_button.onClick = function(self)
			workbench.held_component = tablecopy(component_types[i])
			mouseMode(2)
		end
		component_button.onHover = function(self)
			tooltip = component_types[i]
		end

		-- offsets button dynamically, if it doesn't fit, put on next page (and up the page count)
		y_offset += 16 + component_types[i].height * grid_size
		if y_offset > 250 then
			component_button.y = y + 10
			y_offset = 16 + component_types[i].height * grid_size
			page_count += 1
		end

		component_button.page = page_count
		if page_count > 1 then component_button.visible = false end -- hide if not on first page
		add(component_buttons.buttons, component_button)
	end
	component_buttons.page_max = page_count
	if page_count > 1 then
		initComponentPaginationButtons(x + 43, y)
	end
end

function initComponentPaginationButtons(x, y)
	local previous_page = createButton(x, y, 16, 8)
	previous_page.onClick = function(self)
		component_buttons.page = max(1, component_buttons.page - 1)
		for b in all(component_buttons.buttons) do
			b.visible = false
			if b.page == component_buttons.page then
				b.visible = true
			end
		end
	end
	previous_page.draw = function(self)
		if component_buttons.page == 1 then
			pal(40, 39)
			spr(138, self.x, self.y)
			pal(40, 40)
		elseif self.hover then
			spr(139, self.x, self.y)
		else
			spr(138, self.x, self.y)
		end
	end
	add(buttons, previous_page)

	local next_page = createButton(x + 16, y, 16, 8)
	next_page.onClick = function(self)
		component_buttons.page = min(component_buttons.page_max, component_buttons.page + 1)
		for b in all(component_buttons.buttons) do
			b.visible = false
			if b.page == component_buttons.page then
				b.visible = true
			end
		end
	end
	next_page.draw = function(self)
		if component_buttons.page == component_buttons.page_max then
			pal(40, 39)
			spr(140, self.x, self.y)
			pal(40, 40)
		elseif self.hover then
			spr(141, self.x, self.y)
		else
			spr(140, self.x, self.y)
		end
	end
	add(buttons, next_page)
end

function setupBlueprint(name)
	local bp = {}
	bp.address = "map/blueprints/" .. name .. ".map"
	bp.bitmap = fetch(bp.address)
	return bp
end

function initCanvas()
	local bmp = blueprint.canvas.bitmap[2].bmp -- the second layer of the tilmap has collision data
	local canvas = {
		x = 0,
		y = 0,
		grid_width = bmp:width(),
		grid_height = bmp:height(),
	}
	--canvas grid is used for storing where components are placed
	canvas.grid = init2dTable(canvas.grid_width, canvas.grid_height)
	canvas.space_count = canvas.grid_height * canvas.grid_width
	--set specific spaces as blocked
	for lx = 1, canvas.grid_width do
		for ly = 1, canvas.grid_height do
			if bmp:get(lx - 1, ly - 1) == 192 then
				canvas.grid[ly][lx] = 1 -- grid id for blocked spaces
				canvas.space_count -= 1
			end
		end
	end

	--set offset based on width and height
	canvas.x = 240 - ((canvas.grid_width * grid_size) / 2) + 44
	canvas.y = 135 - ((canvas.grid_height * grid_size) / 2)
	return canvas
end

function getCellListFromRow(index, width)
	local list = {}
	for col = 1, width do
		add(list, {
			x = col,
			y = index
		})
	end
	return list
end

function getCellListFromCol(index, height)
	local list = {}
	for row = 1, height do
		add(list, {
			x = index,
			y = row
		})
	end
	return list
end

function initLineRestrictions(restrictions, bmp)
	for r in all(restrictions) do
		if r.line_type == "col" then
			r.cells = getCellListFromCol(r.index, bmp:height())
		else -- get row
			r.cells = getCellListFromRow(r.index, bmp:width())
		end
	end
end

function addTutorialPopup(content, title, x, y, width)
	local width = width or 180
	local title = title or nil
	local text_formatted, height = textwrap(content, width - 4)
	local x = x or alignCenter(width, 480)
	local y = y or alignCenter(height, 270)
	if title then height += 12 end
	local pop = createButton(x, y, width, height)

	pop.draw = function(self)
		drawWindowGlass(self.x, self.y, self.width, self.height)
		if title then
			rectfill(x + 1, y + 1, x + width - 2, y + 9, 37)
			print(title, self.x + 3, self.y + 2, 35)
			print(text_formatted, self.x + 3, self.y + 12, 17)
		else
			print(text_formatted, self.x + 3, self.y + 2, 17)
		end
	end
	pop.onClick = function(self)
		del(popups, self)
	end

	add(popups, pop)
end

:: scripts/workbench_update.lua
--[[pod_format="raw",created="2024-05-12 09:10:20",modified="2024-11-26 15:07:47",revision=16]]
function updateWorkbench()
    if keyp("q") then
        mouseMode(1) --info
    end
    if keyp("w") then
        mouseMode(2) --place
    end
    if keyp("e") then
        mouseMode(4) --erase
    end
    if keyp("r") and mouse_mode[2] then
        rotateComponent(workbench.held_component)
    end

    if keyp("tab") then
        show_values = toggle(show_values)
    end

    if mouse_val.wheel_y == 1 then
        rotateComponent(workbench.held_component)
    elseif mouse_val.wheel_y == -1 then
        for i = 1, 3 do
            rotateComponent(workbench.held_component)
        end
    end

    -- get tooltip info from placed component
    if mouse_mode[1] and mouseWithinCanvas() then
        local mouse_x, mouse_y = mouse_val.x - workbench.canvas.x, mouse_val.y - workbench.canvas.y
        local mouse_cell_x = ceil(mouse_x / grid_size)
        local mouse_cell_y = ceil(mouse_y / grid_size)
        local cell_id = getCanvasVal(mouse_cell_x, mouse_cell_y)
        if cell_id > 1 then --ignore if marked empty
            for i in all(workbench.placed_components) do
                if i.id == cell_id then
                    tooltip = i
                end
            end
        end
    end

    if mouse_mode[2] and mbtnp(1) then --rotate
        rotateComponent(workbench.held_component)
    end

    for i = 1, component_buttons.page_max do --hot switch component
        if keyp("" .. i) then
            component_buttons.page = i
            for b in all(component_buttons.buttons) do
                b.visible = false
                if b.page == component_buttons.page then
                    b.visible = true
                end
            end
        end
    end

    if mouse_mode[4] and mbtn(0) and mouseWithinCanvas() then --erase
        eraseComponent()
    end

    if mouse_mode[2] and workbench.held_component then --place
        checkPlacement()
        if can_place and mbtn(0) then
            placeComponent()
        end
    end
    for b in all(component_buttons.buttons) do
        buttonUpdate(b)
    end
end

function checkPlacement()
    -- only bother if within canvas bounds
    if mouseWithinCanvas() then
        --offset to canvas origo
        local mouse_x, mouse_y = mouse_val.x - workbench.canvas.x, mouse_val.y - workbench.canvas.y
        local mouse_cell_x = flr(mouse_x / grid_size)
        local mouse_cell_y = flr(mouse_y / grid_size)

        local component = nil
        if mouse_mode[2] then
            component = workbench.held_component
        end
        if component == nil then return end

        --creates a table based on canvas
        local proposed_placement_collider = init2dTable(workbench.canvas.grid_width, workbench.canvas.grid_height)
        --places the held component on it offset by where the mouse is
        can_place = true
        for x = 1, component.width do
            for y = 1, component.height do
                local held_cell = component.collider[y][x]
                local canvas_cell = 0
                if mouse_cell_y + y <= workbench.canvas.grid_height and
                    mouse_cell_x + x <= workbench.canvas.grid_width then
                    canvas_cell = workbench.canvas.grid[mouse_cell_y + y][mouse_cell_x + x]
                    if held_cell > 0 and canvas_cell > 0 then
                        --can't place if held cell is not empty and canvas cell is not empty
                        can_place = false
                        --2 means overlap
                        proposed_placement_collider[mouse_cell_y + y][mouse_cell_x + x] = 2
                    elseif held_cell > 0 then
                        --1 means ok!
                        proposed_placement_collider[mouse_cell_y + y][mouse_cell_x + x] = 1
                    end
                else
                    --can't place if outside of bounds
                    can_place = false
                end
            end
        end
        --set proposed placement
        proposed_placement = {
            x = mouse_cell_x,
            y = mouse_cell_y,
            collider = proposed_placement_collider
        }
        --checks if there is collision and sets can_place
    else
        proposed_placement = nil
        can_place = false
    end
end

function getCanvasVal(x, y)
    local val = nil
    val = workbench.canvas.grid[y][x]
    return val
end

function mouseWithinCanvas()
    if mouse_val.x > workbench.canvas.x
        and mouse_val.x < workbench.canvas.x + grid_size * workbench.canvas.grid_width
        and mouse_val.y > workbench.canvas.y
        and mouse_val.y < workbench.canvas.y + grid_size * workbench.canvas.grid_height then
        return true
    else
        return false
    end
end

function addModifier(modifier_list, modifier) -- can be called even if modifier already exists
    local uniquness_check = true
    for i in all(modifier_list) do
        if i.id == modifier.id then
            uniquness_check = false
        end
    end
    if uniquness_check then
        add(modifier_list, modifier)
    end
end

function removeModifier(modifier_list, modifier_id) --can be called even if modifier doesn't exist
    for i in all(modifier_list) do
        if i.id == modifier_id then
            del(modifier_list, i)
        end
    end
end

function sumModifiers(original, modifiers) -- "printed" value, and then a list of modifiers
    local sum = original
    for i in all(modifiers) do
        sum += i.mod
    end
    return sum
end

function evaluationUpdate()
    workbench.placed_component_amount = countComponents(workbench.placed_components)
    for i in all(workbench.placed_components) do
        if i.ability_instance then
            component_types[i.type].ability_instance(i)
        end
        if i.ability_global then -- set flags for each component type placed
            workbench.global_abilities[i.type] = true
        end

        i.price = max(0, sumModifiers(i.price_original, i.price_modifiers))
        i.power = max(0, sumModifiers(i.power_original, i.power_modifiers))
        i.ichor = max(0, sumModifiers(i.ichor_original, i.ichor_modifiers))
    end

    for i = 1, #component_types do
        if workbench.global_abilities[i] then
            component_types[i].ability_global(component_types[i])
        end
    end

    workbench.power_target = sumModifiers(blueprint.power_target, workbench.power_target_modifiers)
    workbench.sell_target = sumModifiers(blueprint.sell_target, workbench.sell_target_modifiers)
    workbench.cost_of_components = evaluateCost(workbench.placed_components)
    workbench.power_generated = evaluatePower(workbench.placed_components)
    workbench.ichor_generated = evaluateIchor(workbench.placed_components)
    workbench.used_spaces_count = countUsedSpaces(workbench.canvas)

    workbench.restrictions = evaluateRestrictions(blueprint.restrictions)




    if workbench.restrictions
        and workbench.power_generated >= workbench.power_target
        and workbench.cost_of_components <= workbench.sell_target then
        workbench.ready = true
    else
        workbench.ready = false
    end
end

function evaluateRestrictions(restrictions)
    local check = true
    for r in all(restrictions) do
        r.check = r.eval_fun(r)
        if not r.check then
            check = r.check
        end
    end
    return check
end

function evaluatePower(placed_components)
    local total = 0
    for i in all(placed_components) do
        if i.produces_power then
            total += i.power
        end
    end
    total = sumModifiers(total, workbench.power_generated_modifiers)
    return total
end

function evaluateIchor(placed_components)
    local total = 0
    for i in all(placed_components) do
        if i.produces_ichor then
            total += i.ichor
        end
    end
    total = sumModifiers(total, workbench.ichor_generated_modifiers)
    return total
end

function evaluateCost(placed_components)
    local total = 0
    for i in all(placed_components) do
        total += i.price
    end
    total = sumModifiers(total, workbench.costs_modifiers)
    return total
end

function countUsedSpaces(canvas)
    count = 0
    for x = 1, canvas.grid_width do
        for y = 1, canvas.grid_height do
            if canvas.grid[y][x] > 1 then
                count += 1
            end
        end
    end
    return count
end

function placeComponent()
    --offset to canvas origin
    local mouse_x, mouse_y = mouse_val.x - workbench.canvas.x, mouse_val.y - workbench.canvas.y
    local mouse_cell_x = flr(mouse_x / grid_size)
    local mouse_cell_y = flr(mouse_y / grid_size)

    --sets canvas grid cells to held component
    for x = 1, workbench.held_component.width do
        for y = 1, workbench.held_component.height do
            local cell = workbench.held_component.collider[y][x]
            if cell > 0 then
                workbench.canvas.grid[mouse_cell_y + y][mouse_cell_x + x] = workbench.held_component_id
            end
        end
    end
    local neighbors = {}
    for y = 1, workbench.canvas.grid_height do
        for x = 1, workbench.canvas.grid_width do
            if workbench.canvas.grid[y][x] == workbench.held_component_id then
                if workbench.canvas.grid[y - 1][x] ~= workbench.held_component_id then
                    add(neighbors, vec(x, y - 1))
                end
                if workbench.canvas.grid[y + 1][x] ~= workbench.held_component_id then
                    add(neighbors, vec(x, y + 1))
                end
                if workbench.canvas.grid[y][x - 1] ~= workbench.held_component_id then
                    add(neighbors, vec(x - 1, y))
                end
                if workbench.canvas.grid[y][x + 1] ~= workbench.held_component_id then
                    add(neighbors, vec(x + 1, y))
                end
            end
        end
    end

    unique_neighbors = removeDuplicateNeighbors(neighbors)

    local placed_component = tablecopy(workbench.held_component)
    placed_component.x = mouse_cell_x * grid_size + workbench.canvas.x
    placed_component.y = mouse_cell_y * grid_size + workbench.canvas.y
    placed_component.id = workbench.held_component_id

    --modifiers
    placed_component.price_original = placed_component.price
    placed_component.price_modifiers = {}
    placed_component.power_original = placed_component.power
    placed_component.power_modifiers = {}
    placed_component.ichor_original = placed_component.ichor
    placed_component.ichor_modifiers = {}

    placed_component.neighbors = unique_neighbors
    if placed_component.onPlace ~= nil then
        placed_component.onPlace(placed_component)
    end
    add(workbench.placed_components, placed_component)
    workbench.held_component_id += 1
    evaluationUpdate()
    evaluationUpdate()
end

function rotateComponent(held_component)
    held_component.width, held_component.height = held_component.height, held_component.width
    held_component.rotations = (held_component.rotations + 1) % held_component.max_rot
    held_component.collider = rotateMatrix(held_component.collider)
end

function eraseComponent()
    --offset to canvas origin
    local mouse_x, mouse_y = mouse_val.x - workbench.canvas.x, mouse_val.y - workbench.canvas.y
    local mouse_cell_x = ceil(mouse_x / grid_size)
    local mouse_cell_y = ceil(mouse_y / grid_size)

    local id = getCanvasVal(mouse_cell_x, mouse_cell_y)

    if id > 1 then                                   -- only erase if hits something erasable...
        for i in all(workbench.placed_components) do --call onErase
            if i.id == id and component_types[i.type].onErase != nil then
                component_types[i.type].onErase(i)
            end
        end
        for i in all(workbench.placed_components) do
            removeModifier(i.power_modifiers, id)
            removeModifier(i.ichor_modifiers, id)
            removeModifier(i.price_modifiers, id)
            removeModifier(workbench.costs_modifiers, id)
            removeModifier(workbench.power_generated_modifiers, id)
            removeModifier(workbench.ichor_generated_modifiers, id)
            removeModifier(workbench.power_target_modifiers, id)
            removeModifier(workbench.sell_target_modifiers, id)
        end
        -- MISSING: delete global modifiers

        deleteCellsFromCanvas(id)
        deleteComponentFromPlacedComponents(id)

        evaluationUpdate()
        evaluationUpdate()
    end
end

function deleteCellsFromCanvas(id)
    for y = 1, workbench.canvas.grid_height do
        for x = 1, workbench.canvas.grid_width do
            if workbench.canvas.grid[y][x] == id then
                workbench.canvas.grid[y][x] = 0
            end
        end
    end
end

function deleteComponentFromPlacedComponents(id)
    --find the component with the right id, then delete it
    for i in all(workbench.placed_components) do
        if i.id == id then
            del(workbench.placed_components, i)
            return
        end
    end
end

function mouseMode(m) --info, place, mark empty, erase
    local cursor_id = 119 + m
    local cur = get_spr(cursor_id)
    window { cursor = cur }
    for i = 1, #mouse_mode do
        local v = false
        if i == m then v = true end
        mouse_mode[i] = v
    end
end

function countComponents(placed_components)
    local list = {}
    for i = 1, #component_types do
        local count = 0
        for j = 1, #placed_components do
            if placed_components[j].name == component_types[i].name then
                count += 1
            end
        end
        list[i] = count
    end
    return list
end

:: scripts/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI4IDEyOjUxOjEyIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyNyIscmV2aXNpb249NDMyOF1dbHo0ABIBAADCCQAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA--_6H-8B
AMy-6A9AAA1A--_w8HAKAP--ZB--AQD-mVD-----IA==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Iixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCIsc3RvcmVkPSIyMDI0LTA0LTE0IDA3OjU2OjI4Il1d
:: main.lua
--[[pod_format="raw",created="2024-05-12 07:37:40",modified="2025-02-22 13:10:27",revision=101]]
--this should be in main
cd '/source/puzzlegame/'

cp('scripts', '/ram/cart/scripts')
cp('includes', '/ram/cart/includes')
cp('main.lua', '/ram/cart/main_game.lua')

cd '/ram/cart/'

include 'main_game.lua'
:: main_game.lua
--[[pod_format="raw",created="2024-05-12 07:37:40",modified="2024-05-12 09:16:38",revision=93]]

include("scripts/game_init.lua")
include("scripts/ui.lua")
include("scripts/progression.lua")
include("scripts/blueprint_library.lua")
include("scripts/component_library.lua")
include("scripts/generic_draw.lua")
include("scripts/level_select_draw.lua")
include("scripts/level_select_update.lua")
include("scripts/level_select_init.lua")
include("scripts/workbench_init.lua")

include("scripts/workbench_draw.lua")
include("scripts/workbench_update.lua")
include("scripts/helpers.lua")
include("includes/pancelor_mouse.lua")


function _init()
	--set palette
	poke4(0x5000, get(fetch "pal/0.pal"))
	palt(0, false)
	palt(15, true)

	--set font
	poke(0x4000, get(fetch "/system/fonts/lil_mono.font"))

	component_types = initComponentTypes() -- generates exhaustive table of each type of component, using the library

	--tile size of the canvas, components etc
	grid_size = 16

	--for storing the mouse position and whether the a component is picked up
	mouse_val = {
		x = 0,
		y = 0,
		button = 0
	}

	-- for all clickable buttons
	buttons = {}
	popups = {}
	cursor = {}

	-- load progression save file or init if nil
	progression = fetch("/appdata/powertile/progression.pod")
	if progression == nil then
		mkdir("/appdata/powertile")
		mkdir("/appdata/powertile/blueprint_solutions")
		progression = initProgression(blueprint_library)
		updateLevelProgression()
		store("/appdata/powertile/progression.pod", progression)
	end

	-- set start screen
	current_screen = "level select"
	initLevelSelect()

	tooltip = nil
end

function _update()
	tooltip = nil
	cursor = {}
	updateMouse()
	if current_screen == "level select" then
		updateLevelSelect()
	end
	if current_screen == "workbench" then
		updateWorkbench()
	end
	if #popups > 0 then
		buttonUpdate(popups[#popups]) --only update the last one if multiples
		if current_screen == "workbench" then
			for b in all(buttons) do
				buttonUpdate(b)
			end
		end
	else
		for b in all(buttons) do
			buttonUpdate(b)
		end
	end
end

function _draw()
	if current_screen == "level select" then
		cls(21)
		drawLevelSelect()
	end
	if current_screen == "workbench" then
		cls(21)
		drawWorkbench()
	end


	for b in all(buttons) do
		if b.visible then
			b.draw(b)
		end
	end

	if #popups > 0 then
		local p = popups[#popups] --only draw the last one if multiples
		p.draw(p)
	end

	if cursor.draw then
		cursor.draw()
	end
	--debug
	--drawDebug()
end

--error explorer thing for debugging
include("includes/error_explorer.lua")

:: manual.txt
--[[pod_format="raw",created="2024-04-27 07:29:41",modified="2024-04-27 07:29:42",revision=1]]

:: todo.txt
--[[pod_format="raw",created="2024-05-04 12:03:47",modified="2024-05-05 08:23:41",revision=426]]
#TODO
- 	tooltray
	[] scrollable
	[] choose by clicking
	[] component costs
	[] component preview / tooltip
- 	tools
	[x] tool buttons
	[x] separate mark_empty from place completely
-	components
	[] special abilities
-	screens
	[] choose blueprint screen
	[] main menu
	[] game screen
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTIwIDEwOjA0OjMzIixtb2RpZmllZD0iMjAyNS0w
Mi0yMiAxMzoxMDoyOCIscnVudGltZT0xMixzdG9yZWQ9IjIwMjQtMDQtMTQgMTU6MTA6MTIiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJBLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJCLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJDLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJELm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJFLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJGLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ibWFwL2JsdWVw
cmludHMvd2VkMTJHLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4
Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0=
:: [eoc]
